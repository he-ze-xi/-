@[TOC](目录)
# 前言
`大学期间浅学过C++语言，最近工作之余想再细致学习下C++语言。`

---

![在这里插入图片描述](https://img-blog.csdnimg.cn/fcaa640c6b0046129a0e6818449b282e.jpeg#pic_center)
## 1.c++发展历史

> 1. 从80年代到1995年。这一阶段C++语言基本上是传统类型上的面向对象语言，并且凭借这接近c语言的效率，在工业界使用的开发语言中占据了相当大的份额。
> 2. 从1995年到2000年，这一阶段由于标准模板(STL)和后来的Boost程等程序库的出现，泛型程序设计在C++中占据了越来越多的比重。
> 3. 2000年至今，由于以Loki、MPL等程序库为代表产生式编程和模板元编程的出现，C++出现了发展历史上第一个新的高峰。
> 4. 当今主流程序设计语言中最复杂的一员。

## 2.g++介绍

> g++是一款类似于gcc的编译软件，用于编译C++的源代码，使用的方法类似于gcc。
## 3.命名空间
### 1.命名空间简介
> 1. 命名空间是用来防止大型的项目中出现重名的函数、变量或类。
> 2. 比如说，同一个项目的不同模块中出现同名函数或者全局变量，是不可避免发生的情况。而命名空间恰好能解决这个问题。

### 2.命名空间的声明

>  关键字namespace后指定空间名，大括号里进行各种声明。

```csharp
namespace 空间名
{
	//可以在此声明函数、变量、结构体
}
```
### 3.命名空间中函数的定义

> 在此命名空间中声明的函数，在定义时必须在函数名称前加上空间名::，以此来于全局或其他命名空间的函数进行区别，样式如下：

```csharp
返回值类型 空间名::函数名(参数列表)
{
	//函数体
}
```
### 4.命名空间的指定
3种方式：

> 1.  可以使用作用域运算符"::"来指定命名空间。
```csharp
iotek::func();//调用命名空间下的func()
```
> 2. 可以使用using关键字指定命名空间下部分声明
```csharp
using iotek::func;

func();//调用命名空间下的func()
```

> 3. 可以使用using关键字指定命名空间内的全部声明

```csharp
using namespace iotek;

func();//调用命名空间下的func()
```
## 4.输入输出
### 1.简介

>1. 由于C++兼容C语言，因此我们仍然可以使用scanf和printf进行输入和输出。然而，C++本身也有对标准输入输出进行封装，他们就是cin和cout。
>2. 在C++中更推荐使用cin和cout来进行标准输入和输出。
>3. 使用cin和cout的准备工作
```csharp
#include<iostream>
using namespace std;
```
### 2.使用cout进行输出
> 1. cout可以使用多种数据类型的输出，包括所有的基本数据类型，字符数组以及string类型。
> 2. 输出单个数据：
```csharp
cout<<要输出的数据;
```
> 3. 输出多个数据：
```csharp
cout<<要输出的数据<<要输出的数据;
```
>3. 换行输出：
```csharp
cout<<要输出的数据<<endl;//从此endl表示换行
```
### 3.使用cin进行输入
> 1. cin可以使用多种数据类型的输入，包括所有的基本数据类型，字符数组以及string类型。
> 2. 输入单个数据：
```csharp
cin>>要输入的数据;
```
> 3. 输入多个数据：
```csharp
cin>>要输入的对象>>要输入的对象;
```
## 5.对象的概念
> 1. 从广义上讲，要在内存上一段有意义的区域就称之为对象。
> 2. 在C++中，对象一般是指在类中装载的实例，具有相关的成员变量和成员函数。类是抽象的概念，而对象是通过类实现的具体实例。
> 3. 比如说，学生是类，学生小明是对象。

## 6.构造函数和析构函数

> 1. 由于对象一定会在内存中占用一段时间，所以一定会有其生命周期。也就是说对象一定有申请内存空间和释放内存空间的步骤。
> 2. 构造函数是当对象申请内存空间之后自动调用的函数。
> 3. 析构函数是当对象的内存空间即将被销毁前自动调用大的函数。
## 7.new和delete
### 1.简介
> 1. new和delete是C++中的两个关键字，主要用于在向堆中申请或者释放空间。
> 2. 和C语言中申请堆内存不同的是，new和delete在申请/释放内存的时候还会调用构造和析构函数。

### 2.new的使用方法

> 1. 使用new创建对象：
> 类名 *变量名=new 构造函数(参数列表);
> 2. 使用new创建对象数组：
> 类名 *变量名=new 类名[数组的大小];//此时会调用多次构造函数。

### 3.delete的使用方法

> 1. 使用delete销毁对象：
> delete指向对象的指针；//此时会调用析构函数
> 2. 使用delete销毁对象数组：
> delete []对象数组名；//此时会调用多次析构函数
> 3. 注意delete和delete[]的选择。

## 8.this指针

> 1. 当通过对象调用成员函数传递参数时，会额外将本身的地址做为参数传递进入函数。比如说，我们实际上调用成员函数如下：
```csharp
tom.Introduce();
```
> 实际上编译器认为的代码是：
```csharp
tom.Introduce(&tom);
```
> 2. 在函数体的内部可以通过this指针获取到编译器隐式传入的当前对象的地址，并访问对象的成员。例如：
```csharp
this->类成员;
```
## 9.标准库类型String
### 1.简介
> 1. 标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。
> 2. 建议在C++中使用string表示字符串，而不是使用C风格的字符串。
### 2.string类型的操作
>1. 使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间中std中。
```csharp
#include<iostream>
using namespace std;
```
>2. 如何初始化类的对象由类本身决定的，一个类可以有很多种定义初始化的方式，只不过这些方式之间必须有所区别：

```csharp
string s1;//空的字符串
string s2(s1);//初始化说s2为s1的副本
string s3=s2;//初始化s3为s2的副本
string s4="value";//使用字符串常量初始化
```
### 3.String对象的操作

```csharp
s.empty();//s如果为空返回true，否则返回false;
s.size();//返回s中的字符个数;
s[n];//返回s中第n个字符的引用,从0开始;
s1+s2;//返回是s1和s2连接后的结果;
s1=s2;//用s2的副本代替s1中原来的字符;
s1==s2;//判断字符串是否相等;
```
## 10.类的静态成员

> 1. 在C++中，静态成员是属于整个类的属性或行为的，而不是属于某个对象的。

## 11.单例模式
### 1.简介
> 1. 单例模式是一种常用的软件设计模式，在他的核心结构中只包含一个被称为单例的特殊类。
> 2. 通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。

### 2.为什么使用单例模式

> 在应用系统开发中，我们常常有以下需求：
> 1.需要生成唯一序列的环境;
> 2.需要频繁实例化然后销毁的对象;
>3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象;
>4.方便资源相互通信的环境;

> 实际案例:
> 多线程中网络资源初始化
> 回收站机制
> 任务管理器
> 应用程序日志管理
### 3. 实现步骤：
```csharp
1.构造函数私有化
2.提供一个全局的静态方法，访问唯一对象
3.类中定义一个静态指针，指向唯一对象
```
> 懒汉式代码：
```csharp
#include <iostream>
using namespace std;
//懒汉式
class SingleTon
{
    private:
        SingleTon();
    public:
        static SingleTon* m_singleTon;
        static SingleTon* GetInstance();
        void TestPrint();
};

//懒汉式并没有创建单例对象
SingleTon* SingleTon::m_singleTon = NULL;
int main()
{
    SingleTon* p1 = SingleTon::GetInstance();
    SingleTon* p2 = SingleTon::GetInstance();
    cout << "p1:" << hex << p1 << endl;
    cout << "p2:" << hex << p2 << endl;
    p1->TestPrint();
    p2->TestPrint();
    return 0;
}
SingleTon::SingleTon()
{
    m_singleTon = NULL;
    cout << "构造了对象....." << endl;
}
SingleTon* SingleTon::GetInstance()
{
    if (m_singleTon == NULL)
    {
        m_singleTon = new SingleTon;
    }
    return m_singleTon;
}
void SingleTon::TestPrint()
{
    cout << "测试调用....." << endl;
}
```

> 输出结果：
```csharp
构造了对象.....
p1:000002BBB1C672C0
p2:000002BBB1C672C0
测试调用.....
测试调用.....
```
> 饿汉式代码：

```csharp
#include <iostream>
using namespace std;
//懒汉式
class SingleTon
{
private:
    SingleTon();
public:
    static SingleTon* m_singleTon;
    static SingleTon* GetInstance();
    void TestPrint();
};
//饿汉式创建单例对象
SingleTon* SingleTon::m_singleTon = new SingleTon;
int main()
{
    SingleTon* p1 = SingleTon::GetInstance();
    SingleTon* p2 = SingleTon::GetInstance();
    cout << "p1:" << hex << p1 << endl;
    cout << "p2:" << hex << p2 << endl;
    p1->TestPrint();
    p2->TestPrint();
    return 0;
}
SingleTon::SingleTon()
{
    m_singleTon = NULL;
    cout << "构造了对象....." << endl;
}
SingleTon* SingleTon::GetInstance()
{
    return m_singleTon;
}
void SingleTon::TestPrint()
{
    cout << "测试调用....." << endl;
}
```

> 输出结果：
```csharp
构造了对象.....
p1:000002BBB1C672C0
p2:000002BBB1C672C0
测试调用.....
测试调用.....
```
### 4.优缺点
> 优点：
> 1. 在内存中只有一个对象，节省内存空间；
> 2. 避免频繁的创建销毁对象，可以提高性能；
> 3. 避免对共享资源的多重占用，简化访问；
> 4. 为整个系统提供一个全局访问点。

> 缺点：
> 1. 不适用于变化频繁的对象；
> 2. 如果实例化的对象长时间用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；

## 12.const关键字
### 1.const引用

> 1. 由const关键字修饰的引用，称之为对常量的引用，简称为常量引用。
> 2. 和普通引用不同的是，对于常量的引用不能被用作修改它所绑定的对象。
> 比如，如下代码中,r1无法修改ci的值：
```cpp
const int ci=1024;
const int &r1=ci;
```
> 3. 常量引用仅对于引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定，即**const引用即可绑定到常量对象上，也可一绑定到非常量对象上。**
> 4. 尽可能在参数传递时使用const引用。
### 2.const成员函数
> 1. 当成员函数不会更改对象的任何成员变量时，可以将成员函数声明为const。
```cpp
```csharp
class 类名
{
public :
		返回类型 函数名(参数列表) const;
}
返回类型 类名::函数名(参数列表) const;
{
	//函数体
}
```
> 2. const修饰的对象和普通对象不同,他只能调用const修饰的成员函数。而普通对象可以调用任何成员函数。
> 3. 将const修饰成员函数的目的，是为了确认该成员函数可作用于const对象身上。
### 3.const_cast
> 1. 对于将常量对象转换成非常量对象的行为,一般称其为”去掉const性质“。一旦去掉了某个对象的const性质，编译器就不再组织我们对该对象进行写操作了。
> 2. 如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。
> 3. 使用方法：
```cpp
const char *pc;
char *p=const_cast<char*>(pc);
char &r=const_cast<char&>(*pc);
```
## 13.重载
### 1.函数重载
> 1. 编程中，重载是指函数名相同，函数的参数列表不同(包括参数个数和参数类型)，至于返回类型可同可不同。
> 2. 重载是可使相同函数、运算符等处理不同类型数据或接受不同个数的参数的一种方法。
> 3. 如果同一个作用域内的几个函数名字相同但形参列表不同，称之为重载函数。
> 4. 重载的函数接受的形参类型不一样，但是执行的操作非常类似。调用这些函数，编译器会根据传递的实参列表推断想要的函数是哪个。
### 2.运算符重载
#### 1.运算符重载的概念
> 1. 运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。
> 2. 重载的运算符是具有特殊字符的函数：他们的名字由关键字operator和其后要定义的运算符号共同组成：
```cpp
返回类型 operator运算符(参数列表);
```
> 3. 以下运算符是不能重载的：
> 条件运算符    ( ?: )
> 作用域运算符    ( :: )
> 成员指针运算符    ( .* )

#### 2.运算符重载为函数

>  1. 运算符重载为函数的参数数量的运算对象数量一样多。一元运算符有一个参数，二元有两个参数。参数的类型应该根据运算符要操作的对象类型决定。
>  比如说，我们希望重载运算符支持ComplexNumber的加法，则运算符会操作两个ComplexNumber对象：
```cpp
ComplexNumber c1,c2;
ComplexNumber c3=c1+c2;
```
#### 3.运算符重载为成员函数
> 1. 如果要将运算符重载为成员函数，则运算符的第一个操作的元素为当前对象(也就是this指针),如果有第二个操作的元素则由参数指定，因此，运算符重载为成员函数的参数数量比运算符重载为函数的参数数量少一个。
## 14.函数默认参数
> 1. 函数的默认参数值，即在定义参数的时候同时给他一个默认值。在调用函数传参的时候，可以省略含有默认值的参数。
>  例如：
```cpp
void func(int i=0;int j=1);
```


