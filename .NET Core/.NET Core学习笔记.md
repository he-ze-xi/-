﻿@[TOC](目录)

# 前言

![在这里插入图片描述](https://img-blog.csdnimg.cn/f73991c05b654b8ba6d6d09af85459a2.jpeg#pic_center)

# 1.关于.NET

## 1. 什么是.NET？

> .NET是.NET Framework、.NETCore、Xamarin/Mono的统称。



## 2. 什么是.NET FrameWork？

> .NET FrameWork框架只能开发Windows平台的应用程序，也就是说用.NET
> FrameWork框架做出来的程序只能运行在Windows系统下。

## 3. 什么是.NET Core？

> .NET Core框架是免费、开源、跨平台的，可以运行在Linux、Macos、Windows平台下。

## 4.NET Core的优点

>  1. 支持独立部署，不相互影响；
>  2. 彻底模块化；
>  3. 没有历史包袱，运行效率高；
>  4. 不依赖于IIS;
>  5. 跨平台;
>  6. 符合现代开发理念：依赖注入、单元测试等。

# 2.异步编程

## 1.C#中async、await关键字

> 异步方法：用async关键字修饰的方法。
>
>   1. 异步方法的返回值一般是Task<T>，T是真正的返回值类型，Task<int>。惯例：异步方法的名字以Async结尾；
>   2. 即使方法没有返回值，也最好把返回值声明为非泛型的Task；
>   3. 调用泛型方法时，一般在方法前加上await关键字，这样拿到的返回值就是泛型指定的T类型；
>   4. 异步方法的”传染性“：一个方法如果await调用，则这个方法也必须修改为async；
>   5. 如果一个方法是异步方法，那么一般在调用这个方法的时候在方法前加await关键字，如：

```csharp
await File.WriteAllTextAsync(filename,html);
```

> 体验下异步编程，如：

```csharp
 public class Program
    {
        static async Task Main(string[] args)
        {
            string fileName = @"D:\1.txt";//该行也可以写成string fileName = "D:/1.txt";
            File.Delete(fileName);//删除文件
            StringBuilder str = new StringBuilder();
            for(int i = 0; i < 10000; i++)
            {
                str.Append(",Hello");
            }
             File.WriteAllTextAsync(fileName,str.ToString());
            string s=await File.ReadAllTextAsync(fileName);
            Console.WriteLine(s);
        }
    }
```

> 运行程序会报错，因为File.WriteAllTextAsync(fileName,str.ToString())前没有await关键字，程序运行到此行时，不会跳过此行，会一直执行此行知道此行执行结束，但是由于下一行中的File.ReadAllTextAsync(fileName)前有await，因此运行此代码会报错（报错原因：同一个文件不能同时被一个进程读和另外一个进程写）。
> 如下图，在File.WriteAllTextAsync(fileName,str.ToString())方法前加一个await关键字就可以了：

```csharp
public class Program
    {
        static async Task Main(string[] args)
        {
            string fileName = @"D:\1.txt";//该行也可以写成string fileName = "D:/1.txt";
            File.Delete(fileName);//删除文件
            StringBuilder str = new StringBuilder();
            for(int i = 0; i < 10000; i++)
            {
                str.Append(",Hello");
            }
            await File.WriteAllTextAsync(fileName,str.ToString());
            string s=await File.ReadAllTextAsync(fileName);
            Console.WriteLine(s);
        }
    }
```

## 2.编写异步方法

> 1.自定义两个异步方法，一个不带返回值，一个带返回值，如下：

```csharp
 public class Program
    {
       public static async Task Main(string[] args)
        {
             await DownloadHtmlAsync1("https://www.youzack.com", @"D:/1.txt");
            Console.WriteLine("Ok");
            Console.WriteLine("**************");
            Console.WriteLine("**************");
            Console.WriteLine("**************");
            int len2= await DownloadHtmlAsync2("https://www.youzack.com", @"D:/2.txt");
            Console.WriteLine("Ok"+len2);
        }

        /// <summary>
        /// 自定义一个异步方法(不带返回值)，用于从网页上下载html文件，并写在本地文件中
        /// </summary>
        /// <param name="url">
        /// html文件的下载地址
        /// </param>
        /// <param name="filename">
        /// 下载的html文件保存在本地哪个文件中
        /// </param>
        /// <returns></returns>
        public static async Task DownloadHtmlAsync1(string url, string filename)
        {
            HttpClient httpClient = new HttpClient();
            string html = await httpClient.GetStringAsync(url);
            await File.WriteAllTextAsync(filename, html);
        }

        /// <summary>
        /// 自定义一个异步方法(带返回值)，用于从网页上下载html文件，并写在本地文件中
        /// </summary>
        /// <param name="url">
        /// html文件的下载地址
        /// </param>
        /// <param name="filename">
        /// 下载的html文件保存在本地哪个文件中
        /// </param>
        /// <returns></returns>
        public static async Task<int> DownloadHtmlAsync2(string url, string filename)
        {
            HttpClient httpClient = new HttpClient();
            string html = await httpClient.GetStringAsync(url);
            await File.WriteAllTextAsync(filename, html);
            return html.Length;
        }
    }
}
```

> 2.如果同样的功能，既有同步方法，又有异步方法，那么优先使用异步方法。
> 3.异步lambda表达式(委托) 例如：

```csharp
 public class Program
    {
        public static void Main()
        {
            ThreadPool.QueueUserWorkItem(async (obj) =>
            {
                while (true)
                {
                    await File.WriteAllTextAsync(@"D:/3.txt", "sdfffffffffffffffffff");
                }
               
            });
            Console.ReadKey();
        }
    }
```

## 3.异步方法并不等于多线程

> **异步方法中的代码并不会自动在新线程中执行，除非把代码放到新线程中执行（通过Task.Run方法将代码放到新的线程中执行）。** 看下不使用Task.Run方法和使用Task.Run方法的效果： 不使用Task.Run方法:

```csharp
public class Program
    {
        public static async Task Main()
        {
            Console.WriteLine("之前" + Thread.CurrentThread.ManagedThreadId);
            double r = await CalcAsync(5000);
            Console.WriteLine("之后" + Thread.CurrentThread.ManagedThreadId);
        }

        public static async Task<double> CalcAsync(int n)
        {
            Console.WriteLine("CalcAsync" + Thread.CurrentThread.ManagedThreadId);
            double result = 0;
            Random random = new Random();
            for(var i = 0; i < n * n; i++)
            {
                result+=random.NextDouble();
            }
            return result;
        }
    }
```

> 使用Task.Run方法:

```csharp
 public class Program
    {
        public static async Task Main()
        {
            Console.WriteLine("之前" + Thread.CurrentThread.ManagedThreadId);
            double r = await CalcAsync(5000);
            Console.WriteLine("之后" + Thread.CurrentThread.ManagedThreadId);
        }

        public static async Task<double> CalcAsync(int n)
       {
            return await Task.Run(() =>
            { 
                Console.WriteLine("CalcAsync" + Thread.CurrentThread.ManagedThreadId);
                double result = 0;
                Random random = new Random();
                for (var i = 0; i < n * n; i++)
                {
                    result += random.NextDouble();
                }
                return result;
            });
        }
    }
```

## 4.为什么有的异步方法没标async

> 1.async方法的缺点：
>
>   1. 异步方法会生成一个类，运行效率没有普通方法高;
>   2. 可能会占用非常多的线程; 用async和await配合来调用普通方法(推荐此方式,运行效率高),例如：

```csharp
public class Program
    {
        public static async Task Main()
        {
            string s = await ReadAsync(1);
            Console.WriteLine(s);
        }

        public static Task<string> ReadAsync(int n)
        {
            if (n == 1)
            {
                return File.ReadAllTextAsync(@"D:/1.txt");
                
            }else if (n == 2)
            {
                return File.ReadAllTextAsync(@"D:/2.txt");
            }
            else
            {
                throw new ArgumentException();
            }
        }
    }
```

## 5.不要用sleep

> 1.Thread.Sleep()方法阻塞的是当前线程，如果当前线程是主线程，那么调用Sleep方法就会阻塞主线程。如果想在异步方法中暂停一段时间，不要用Thread.Sleep()方法，因为它会阻塞调用线程，而要用await
> Task.Delay()。举例：下载一个网址，3秒后下载另外一个。
>
> 例如，新建一个Winfrom程序（选用winform程序而不采用控制台为例子是因为在控制台中看不到区别，但是在winfrom程序中就可以看到区别，在ASP.NET
> Core中也看不到区别，但是Sleep()方法会降低并发，因此不要用Sleep()方法）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/c1b7c94a1e7445278c7e0fec40571be5.png#pic_center)

> 在后台的代码如下：

```csharp
 private async void button1_Click(object sender, EventArgs e)
        {
            HttpClient httpClient=new HttpClient();
            string s1= await httpClient.GetStringAsync("https://www.youzack.com");
            textBox1.Text = s1.Substring(0, 2000);
            //Thread.Sleep(3000);
            await Task.Delay(3000);
            string s2 = await httpClient.GetStringAsync("https://www.baidu.com");
            textBox1.Text = s2.Substring(0, 200);
        }
```

## 6.CancellationToken

> 1.有时需要提前终止任务，比如：请求超时、用户取消请求。很多异步方法都有CancellationToken参数，用于获得提前终止执行的信号。
> 2.CancellationToken结构体：
>
>   1. bool IsCancellationRequested是否取消
>   2. Register(Action callback) 注册取消监听
>   3. ThrowIfCancellationRequested()如果任务被取消，执行到这句话就抛异常。
>      3.CancellationTokenSource类
>   4. CancelAfter()超时后发出取消信号
>   5. Cancel()发出取消信号
>   6. CancellationToken Token 代码举例1，5秒后请求被取消：

```csharp
public class Program
    {
        public static async Task  Main(string[] args)
        {
            //await Download1Async("https://www.youzack.com", 100);

            CancellationTokenSource cts=new CancellationTokenSource();
            cts.CancelAfter(5000);
            CancellationToken cToken=cts.Token;
            await Download2Async("https://www.youzack.com",100,cToken);
        }

        /// <summary>
        /// 不带CancellationToken的方法
        /// </summary>
        /// <param name="url"></param>
        /// <param name="n"></param>
        /// <returns></returns>
        public static async Task Download1Async(string url,int n)
        {
            HttpClient client = new HttpClient(); 
            for(int i = 0; i < n; i++)
            {
                string html=await client.GetStringAsync(url);
                Console.WriteLine($"{DateTime.Now}:{html}");
            }
        }


        /// <summary>
        /// 带CancellationToken的方法
        /// </summary>
        /// <param name="url"></param>
        /// <param name="n"></param>
        /// <returns></returns>
        public static async Task Download2Async(string url, int n, CancellationToken cancellationToken)
        {
            HttpClient client = new HttpClient();
            for (int i = 0; i < n; i++)
            {
                string html = await client.GetStringAsync(url);
                Console.WriteLine($"{DateTime.Now}:{html}");
                if (cancellationToken.IsCancellationRequested)
                {
                    Console.WriteLine("请求被取消");
                    break;
                }
            }
        }
    }
```

> 4.在ASP.NET Core开发中，一般不需要自己处理cancellationToken、CancellationTokenSource 这些，只要能做到“能转发cancellationToken”即可。在ASP.NET Core会对用户请求中断进行处理。

## 7.WhenAll

> 1.Task类的重要方法：
>
>   1. Task<Task> **WhenAny**(IEnumerable<Task> tasks)等，任何一个Task完成，Task就完成；
>   2. Task<TResult[]> **WhenAll**<TResult>(params Task<TResult>[] tasks)方法：等所有Task完成，Task才完成，用于等待多个任务执行结束，但是他们不在乎他们的执行顺序。
>   3. Task<TResult> **FromResult**<TResult>(TResult result)方法：创建普通数值的Task对象。
>      2.代码练习：计算一个文件夹下，所有文本文件的单词个数汇总。代码如下：

```csharp
public class Program
    {
        public static async Task  Main(string[] args)
        {
            string[] files=Directory.GetFiles(@"D:/Test");
            Task<int>[] countTasks=new Task<int>[files.Length];
            for(int i=0; i<files.Length; i++)
            {
                string filename=files[i];
                Task<int> t = ReadCharsCount(filename);
                countTasks[i] = t;
            }
            int[] counts=await Task.WhenAll(countTasks);
            int c = counts.Sum();//计算数组中所有元素的和
            Console.WriteLine(c);
        }

        static async Task<int> ReadCharsCount(string filename)
        {
            string s=await File.ReadAllTextAsync(filename);
            return s.Length;
        }
    }
```

## 8.异步编程中其他问题

### 1.接口中的异步方法：

> async是提示编译器为异步方法中的await代码进行分段处理的，而一个异步方法是否修饰了async对于方法的调用者来讲是没区别的，因此对于接口中的方法或抽象方法不能修饰为async。
> 如：

```csharp
public interface Itest
{
    Task<int> GetCharCount(string file);
}
public class Test : Itest
{
    public async Task<int> GetCharCount(string file)
    {
        string s = await File.ReadAllTextAsync(file);
        return s.Length;
    }
}
```

### 2.异步与yield

> yield return不仅能够简化数据的返回，而且可以让数据处理"流水线化",提升性能。 如：

```csharp
public class Program
    {
        public static async Task  Main(string[] args)
        {
            IEnumerable<string> lists= Test();
            foreach(var item in lists)
            {
                Console.WriteLine(item);
            }
        }

      public static IEnumerable<string> Test()
        {
            yield return "hello1";
            yield return "hello2";
            yield return "hello3";
        }
    }
```

# 3.LINQ

## 1.为什么要学习LINQ? 

> 1.答案是让数据处理变得简单。 比如，现在有这样一个需求：统计一个字符串中每个字母出现的频率（忽略大小写）,然后按照从高到低的顺序输出出现频率高于2次的单词和其出现的频率。用LINQ的知识很容易就可以写出来：

```csharp
            var items = s.Where(c => char.IsLetter(c)) //过滤非字母
                .Select(c => char.ToLower(c)) //大写字母转化为小写
                .GroupBy(c => c)//根据字母进行分组
                .Where(g => g.Count() > 2)//过滤掉出现次数小于2
                .OrderByDescending(g => g.Count())//按照出现次数排序
                .Select(g => new { Char = g.Key, Count = g.Count() });
```

>  2.要想把LINQ学好，需要按照委托---lambda---LINQ的顺序来，即先把委托学好，再学好委托中lamda，最后学习LINQ。

##  2.LINQ中的常用扩展方法

> LINQ中提供了大量类似于Where的扩展方法，简化数据处理，大部分都在System.Linq命名空间中。

### 1.Where方法：根据条件执行操作

### 2.Count方法：获取数据的条数

### 3.Any方法：是否至少有一条数据

> 如：

```csharp
bool b1 = List.Any(e => e.Salary > 8000);
bool b2 = List.Where(e => e.Salary > 8000).Any();
```

### 4.获取一条数据（是否带有参数的两种写法）

> - Single:有且只有一条满足要求的数据；
> - SingleOrDefault:最多只有一条要满足的数据；
> - First:至少有一条，返回第一条；
> - FirstOrDefault:返回第一条或默认值；

### 5.排序

> - Order() 升序排序；
> - OrderByDescending() 倒序排序；
> - list.OrderBy(e => e.Age);//根据Age来对集合进行升序排序; 对于简单类型排序，也许不用lambda表达式。 特殊案例：按照最后一个字符排序；用Guid或者随机数进行随机排序。

### 5.多规则排序

> 可以在Order()、OrderByDescending()后继续写ThenBy () 、ThenByDescending()。
> 案例：优先按照Age排序，如果Age相同再按照Salary排序。 list.OrderBy(e =>
> e.Age).ThenByDescending(e => e.Salary)， 千万不要写成list.OrderBy(e =>
> e.Age). OrderByDescending (e => e.Salary)。

### 6.限制结果集，获取部分数据

> Skip(n)跳过n条数据，Take(n)获取n条数据。 案例：跳过前2条数据并开始获取之后的3条数据(即获得第3、4、5条数据)： var
> orderedItems1 = list.Skip(2).Take(3); Skip()、Take()也可以单独使用。

### 7.聚合函数

> Max()、Min () 、Average () 、Sum () 、Count ()。
> LINQ中所有的扩展方法几乎都是针对IEnumerable接口的，而几乎所有能返回集合的都返回IEnumerable，所以是可以把几乎所有方法“链式使用”的。
> list.Where(e => e.Age > 30).Min(e=>e.Salary)。 代码举例：

```csharp
public static void Main()
{
    List<Employee> list = new List<Employee>();
    list.Add(new Employee { Id = 1, Name = "jerry", Age = 28, Gender = true, Salary = 5000 });
    list.Add(new Employee { Id = 2, Name = "jim", Age = 33, Gender = true, Salary = 3000 });
    list.Add(new Employee { Id = 3, Name = "lily", Age = 35, Gender = false, Salary = 9000 });
    list.Add(new Employee { Id = 4, Name = "lucy", Age = 16, Gender = false, Salary = 2000 });
    list.Add(new Employee { Id = 5, Name = "kimi", Age = 25, Gender = true, Salary = 1000 });
    list.Add(new Employee { Id = 6, Name = "nancy", Age = 35, Gender = false, Salary = 8000 });
    list.Add(new Employee { Id = 7, Name = "zack", Age = 35, Gender = true, Salary = 8500 });
    list.Add(new Employee { Id = 8, Name = "jack", Age = 33, Gender = true, Salary = 9000 });

	int maxAge = list.Max(e => e.Age);
	Console.WriteLine($"最大年龄:{maxAge}");
	long minId = list.Min(e => e.Id);
	Console.WriteLine($"最小Id:{minId}");
	double avgSalary = list.Average(e => e.Salary);
	Console.WriteLine($"平均工资:{avgSalary}");
	int sumSalary = list.Sum(e => e.Salary);
	Console.WriteLine($"工资总和:{sumSalary}");
	int count = list.Count();
	Console.WriteLine($"总条数:{count}");
	int minSalary2 = list.Where(e => e.Age > 30).Min(e => e.Salary);
	Console.WriteLine($"大于30岁的人群中的最低工资:{minSalary2}");

}
```

```csharp
record Employee
{
    public long Id { get; set; }
    public string Name { get; set; }
    public int Age { get; set; }
    public bool Gender { get; set; }
    public int Salary { get; set; }
}
```

> 运行结果：

![在这里插入图片描述](https://img-blog.csdnimg.cn/f8d61a8479e84225a47f73d03d2eafd5.png#pic_center)

### 8.分组GroupBy方法

> GroupBy()方法参数是分组条件表达式，根据条件将一个大点的集合分成多个小集合。 例子：根据年龄分组，获取每组人数、最高工资、平均工资：

```csharp
public static void Main()
{
    List<Employee> list = new List<Employee>();
    list.Add(new Employee { Id = 1, Name = "jerry", Age = 28, Gender = true, Salary = 5000 });
    list.Add(new Employee { Id = 2, Name = "jim", Age = 33, Gender = true, Salary = 3000 });
    list.Add(new Employee { Id = 3, Name = "lily", Age = 35, Gender = false, Salary = 9000 });
    list.Add(new Employee { Id = 4, Name = "lucy", Age = 16, Gender = false, Salary = 2000 });
    list.Add(new Employee { Id = 5, Name = "kimi", Age = 25, Gender = true, Salary = 1000 });
    list.Add(new Employee { Id = 6, Name = "nancy", Age = 35, Gender = false, Salary = 8000 });
    list.Add(new Employee { Id = 7, Name = "zack", Age = 35, Gender = true, Salary = 8500 });
    list.Add(new Employee { Id = 8, Name = "jack", Age = 33, Gender = true, Salary = 9000 });
	var items = list.GroupBy(e => e.Age);
	foreach (var item in items)
	{
	    int age = item.Key;
	    int count = item.Count();
	    int maxSalary = item.Max(e => e.Salary);
	    double avgSalary = item.Average(e => e.Salary);
	    Console.WriteLine($"年龄{item.Key},人数{count},最高工资{maxSalary},平均工资{avgSalary}");
	}
}
```

### 9.投影select方法

> 通过Select方法把集合中的每一项转换为另外一种类型。 IEnumerable<int> ages = list.Select(e =>
> e.Age); IEnumerable<string> names = list.Select(e=>e.Gender?"男":"女");
> var dogs = list.Select(p=>new Dog{NickName=e.Name,Age=e.Age}); 代码如下：

```csharp
public static void Main()
{
    List<Employee> list = new List<Employee>();
    list.Add(new Employee { Id = 1, Name = "jerry", Age = 28, Gender = true, Salary = 5000 });
    list.Add(new Employee { Id = 2, Name = "jim", Age = 33, Gender = true, Salary = 3000 });
    list.Add(new Employee { Id = 3, Name = "lily", Age = 35, Gender = false, Salary = 9000 });
    list.Add(new Employee { Id = 4, Name = "lucy", Age = 16, Gender = false, Salary = 2000 });
    list.Add(new Employee { Id = 5, Name = "kimi", Age = 25, Gender = true, Salary = 1000 });
    list.Add(new Employee { Id = 6, Name = "nancy", Age = 35, Gender = false, Salary = 8000 });
    list.Add(new Employee { Id = 7, Name = "zack", Age = 35, Gender = true, Salary = 8500 });
    list.Add(new Employee { Id = 8, Name = "jack", Age = 33, Gender = true, Salary = 9000 });
	var ages = list.Select(e => e.Age);
	Console.WriteLine(string.Join(",", ages));
	var names = list.Select(e => e.Gender ? "男" : "女");
	Console.WriteLine(string.Join(",", names));
	
	
	var items1 = list.Select(e => new { e.Name, e.Age, XingBie = e.Gender ? "男" : "女" });
	foreach (var item in items1)
	{
	    string name = item.Name;
	    int age = item.Age;
	    string xingbie = item.XingBie;
	    Console.WriteLine($"名字={name},年龄={age},性别={xingbie}");
	}
	
	var items2 = list.GroupBy(e => e.Gender).Select(g => new
	{
	    Gender = g.Key,
	    Count = g.Count(),
	    AvgSalary = g.Average(e => e.Salary),
	    MinAge = g.Min(e => e.Age)
	});
	foreach (var item in items2)
	{
	    Console.WriteLine($"性别{item.Gender},人数{item.Count},平均工资{item.AvgSalary:F},最小年龄{item.MinAge}");
	}
}
```

> 运行结果：

![在这里插入图片描述](https://img-blog.csdnimg.cn/3108997189b24211b36b1ba8d7897c78.png#pic_center)

### 10.匿名类型

> var p = new {Name="tom",Id=1}; var p1 = new {name,Id=1,p.Age};
> 通过反编译看匿名类型原理。

### 11.投影与匿名类型(很常用)

```csharp
var items = list.Select(e=>new {e.Name,e.Age,XingBie= e.Gender ? "男" : "女"});
var items = list.GroupBy(e => e.Gender).Select(g=>new { Gender=g.Key,Count=g.Count(),AvgSalary= g.Average(e => e.Salary),MinAge= g.Min(e => e.Age)});
```

## 3.LINQ中的链式调用

### 1.集合转换

> 有一些地方需要数组类型或者List类型的变量，我们可以用ToArray()方法和ToList()分别把IEnumerable<T>转换为数组类型和List<T>类型。

### 2.链式调用

> Where、Select、OrderBy、GroupBy、Take、Skip等返回值都是IEnumerable<T>类型，所以可以链式调用。例子：“获取Id>2的数据，然后按照Age分组，并且把分组按照Age排序，然后取出前3条，最后再投影取得年龄、人数、平均工资”。
> 代码举例：

```csharp
public static void Main()
{
    List<Employee> list = new List<Employee>();
    list.Add(new Employee { Id = 1, Name = "jerry", Age = 28, Gender = true, Salary = 5000 });
    list.Add(new Employee { Id = 2, Name = "jim", Age = 33, Gender = true, Salary = 3000 });
    list.Add(new Employee { Id = 3, Name = "lily", Age = 35, Gender = false, Salary = 9000 });
    list.Add(new Employee { Id = 4, Name = "lucy", Age = 16, Gender = false, Salary = 2000 });
    list.Add(new Employee { Id = 5, Name = "kimi", Age = 25, Gender = true, Salary = 1000 });
    list.Add(new Employee { Id = 6, Name = "nancy", Age = 35, Gender = false, Salary = 8000 });
    list.Add(new Employee { Id = 7, Name = "zack", Age = 35, Gender = true, Salary = 8500 });
    list.Add(new Employee { Id = 8, Name = "jack", Age = 33, Gender = true, Salary = 9000 });
	var items = list.Where(e => e.Id > 2).GroupBy(e => e.Age).OrderBy(g => g.Key).Take(3)
	   				.Select(g => new { Age = g.Key, Count = g.Count(), AvgSalary = g.Average(e => e.Salary) });
	foreach (var item in items)
	{
	    Console.WriteLine($"年龄:{item.Age},人数：{item.Count},平均工资:{item.AvgSalary}");
	}
```

> 运行结果：

![在这里插入图片描述](https://img-blog.csdnimg.cn/d8f7e7fb251a4686a7e98f46ae08a685.png#pic_center)

## 4.LINQ中小知识补充

### 1.过滤掉字符串中的非字母(即只保留字符串中的字母)

> 例如，有如下这样一段字符串：

```xml
sdfgsdgdffffreqqwertyuiopasdfghjklzxcvbnm,yhndhsfdsgfeybxnzzzzzzzzcyweferoqweyrei./,\]-=sadjsfhjdsfjuewxbcvc
```

> 现在要把所有的非字母过滤掉，可以很方便地用LINQ中的方法实现：

```csharp
            string str = @"sdfgsdgdffffreqqwertyuiopasdfghjklzxcvbnm,yhndhsfdsgfeybxnzzzzzzzzcyweferoqweyrei./,\]-=sadjsfhjdsfjuewxbcvc";
            var result = str.Where(c => char.IsLetter(c));//选择字母,即过滤掉非字母         
            foreach(var item in result)
            {
                Console.Write(item+" ");
            }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/e3baf8ddb5c44309930d20ea2971409d.png#pic_center)

### 5.LINQ练习题

> 习题1：
> 有一个用逗号分隔的表示成绩的字符串，如"61,90,100,99,18,22,38,66,80,93,55,50,89"，计算这些成绩的平均值。

```csharp
 public class Program
    {
        static void Main(string[] args)
        {
            List<int> lists = new List<int>() { 61, 90, 100, 99, 18, 22, 38, 66, 80, 93, 55, 50, 89 };
            var results = lists.Average();//求出集合中的平均数
            Console.WriteLine(results);
        }
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/61414ac1f1604fb3a6903831ba8981a0.png#pic_center)

> 习题2： 统计一个字符串中每个字母出现的频率（忽略大小写），然后按照从高到低的顺序输出出现频率高于2次的单词和其出现的频率。

```csharp
    public class Program
    {
        static void Main(string[] args)
        {
            string str = @"sdfgsdgdffffreqqwertyuiopasdfghjklzxcvbnm,yhndhsfdsgfeybxnzzzzzzzzcyweferoqweyrei./,\]-=sadjsfhjdsfjuewxbcvc";
            var result = str.Where(c => char.IsLetter(c))//选择字母,即过滤掉非字母
                            .Select(c => char.ToLower(c))//大写字母全部转换为小写
                            .GroupBy(c => c)//根据字母进行分组
                            .Where(c => c.Count() > 2)//过滤掉字母出现频率低于2的
                            .OrderByDescending(c => c.Count())//根据出现次数降序排序（即出现次数多的排在前面）
                            .Select(c => new { Key = c.Key, Count = c.Count() });//实例化一个匿名对象，并赋值字符的值和出现的次数
                                
           foreach(var item in result)
           {
               Console.WriteLine(item);
           }
        }
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/0f0816464a5d4548bd9a75221d02202b.png#pic_center)

# 4.依赖注入

> [大佬写的很详细的关于依赖注入和控制反转的博客](https://blog.csdn.net/HerryDong/article/details/124097518)

## 1.依赖注入与控制反转的概念

> 1. 生活中的“控制反转”：自己发电和用电网的电。
> 2. 依赖注入（Dependency Injection，DI）是控制反转（Inversion of Control，IOC）思想的实现方式。
> 3. **依赖注入作用：简化模块的组装过程，降低模块之间的耦合度。**
> 4. 代码控制反转的目的：“怎样创建XX对象”→“我要XX对象” 两种实现方式： &emsp;&emsp;- 服务定位器(ServiceLocator)； &emsp;&emsp;-  依赖注入(Dependency Injection，DI)；
> 5. 畅想Demo 两种方式代码比较： 
>    &emsp;&emsp;- 服务定位器 ```csharp IDbConnection conn = ServiceLocator.GetService<IDbConnection>(); ```
>    &emsp;&emsp;- 依赖注入

```csharp
class Demo
{
    public IDbConnection Conn { get; set; }
    public void InsertDB()
    {
        IDbCommand cmd = Conn.CreateCommand();
    }
}
```

## 2.NET中DI服务注册

### 1.DI的几个概念

> 服务(service)：对象； 注册服务； 服务容器：负责管理注册的服务； 查询服务：创建对象及关联对象；
> 对象生命周期：**Transient(瞬态); Scoped（范围）; Singleton（单例）;**

### 2.NET中使用DI

> 1.根据类型来获取和注册服务。
> 2.可以分别指定服务类型（service type）和实现类型（implementation type）。这两者可能相同，也可能不同。服务类型可以是类，也可以是接口，建议面向接口编程，更灵活。
> 3.NET控制反转组件取名为DependencyInjection，但它包含ServiceLocator的功能。
> 4.使用DI的步骤：
>
> 1. Install-Package Microsoft.Extensions.DependencyInjection
> 2. using Microsoft.Extensions.DependencyInjection
> 3. ServiceCollection用来构造容器对象IServiceProvider 。调用ServiceCollection的BuildServiceProvider()创建的ServiceProvider，可以用来获取BuildServiceProvider()之前ServiceCollection中的对象。
>
> 5.一个简单的例子：

```csharp
using System;
using Microsoft.Extensions.DependencyInjection;
namespace ConsoleApp1
{
    public interface ITestService
    {
        public string Name { get; set; }
        public void SayHi();
    }
    public class TestServiceImpI: ITestService
    {
        public string Name { get; set; }
        public void SayHi()
        {
            Console.WriteLine($"Hi,I'm{Name}");
        }
    }

    public class TestServiceImpI2 : ITestService
    {
        public string Name { get; set; }
        public void SayHi()
        {
            Console.WriteLine($"你好,我是{Name}");
        }
    }

    public class Program
    {
        public static void Main()
        {
            //ITestService t = new TestServiceImpI();
            //t.Name = "tom";
            //t.SayHi();
            ServiceCollection services = new ServiceCollection();
            services.AddTransient<TestServiceImpI>();
            using (ServiceProvider sp = services.BuildServiceProvider())
            {
                TestServiceImpI t= sp.GetService<TestServiceImpI>();
                t.Name = " Lily";
                t.SayHi();
            };
            Console.ReadKey();
        }
    }
}
```

## 3.服务的生命周期

> 1.给类构造函数中打印，看看不同生命周期的对象创建，使用serviceProvider.CreateScope()创建Scope。
> 2.如果一个类实现了IDisposable接口，则离开作用域之后容器会自动调用对象的Dispose方法。
> 3.不要在长生命周期的对象中引用比它短的生命周期的对象。在ASP.NET Core中，这样做默认会抛异常。
> 4.生命周期的选择：如果类无状态，建议为Singleton；如果类有状态，且有Scope控制，建议为Scoped，因为通常这种Scope控制下的代码都是运行在同一个线程中的，没有并发修改的问题；在使用Transient的时候要谨慎。
> 5.NET注册服务的重载方法很多，看着文档琢磨吧。

## 4.服务定位器

> - IServiceProvider的服务定位器方法：
> - T GetService<T>() 如果获取不到对象，则返回null;
> - object GetService(Type serviceType);
> - T GetRequiredService<T>()如果获取不到对象，则抛异常;
> - object GetRequiredService(Type serviceType) ;
> - IEnumerable<T> GetServices<T>()适用于可能有很多满足条件的服务;
> - IEnumerable<object> GetServices(Type serviceType)。

## 5.DI魅力渐显：依赖注入

> 1.依赖注入是有“传染性”的，如果一个类的对象是通过DI创建的，那么这个类的构造函数中声明的所有服务类型的参数都会被DI赋值；但是如果一个对象是程序员手动创建的，那么这个对象就和DI没有关系，它的构造函数中声明的服务类型参数就不会被自动赋值。
> 2..NET的DI默认是构造函数注入。
> 3.案例：编写一个类，记录日志（模拟的输出），把Dao、日志都放入单独的服务类。 代码如下：

```csharp
using System;
using Microsoft.Extensions.DependencyInjection;
namespace DI会传染
{
    public class Program
    {
        static void Main(string[] args)
        {
            ServiceCollection services = new ServiceCollection();
            services.AddScoped<Controller>();
            services.AddScoped<ILog,LogImpl>();
            services.AddScoped<IStorage, StorgeImpl>();
            services.AddScoped<IConfig, ConfigImpl>();

            using(var sp = services.BuildServiceProvider())
            {
              var c=sp.GetRequiredService<Controller>();
                c.Test();
            }
            Console.ReadKey();
        }
    }

    public class Controller
    {
        private readonly ILog log;
        private readonly IStorage storage;
        public Controller(ILog log, IStorage storage)
        {
            this.log = log;
            this.storage = storage;
        }
        public void Test()
        {
            this.log.Log("开始上传");
            this.storage.Save("33333333333", "3.txt");
            this.log.Log("上传完毕");
        }
    }

    /// <summary>
    /// 日志相关
    /// </summary>
    public interface ILog
    {
        public void Log(string msg);
    }
    public class LogImpl : ILog
    {
        public void Log(string msg)
        {
            Console.WriteLine($"日志:{msg}");
        }
    }

    /// <summary>
    /// 配置相关
    /// </summary>
    public interface IConfig
    {
        public string GetValue(string name);
    }
    public class ConfigImpl : IConfig
    {
        public string GetValue(string name)
        {
            return "你好";
        }
    }
    
    /// <summary>
    /// 云存储相关
    /// </summary>
    public interface IStorage
    {
        public void Save(string content,string name);
    }
    public class StorgeImpl : IStorage
    {
        private readonly IConfig config;
        public StorgeImpl(IConfig config)
        {
            this.config = config;
        }
        public void Save(string content, string name)
        {
            string server = config.GetValue("server");
            Console.WriteLine($"向服务器{server}的文件名为{name}上传{content}");
        }
    }
}
```

运行结果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/3f3295b8de5446aeb93c76aacacc461b.png#pic_center)

# 5.ASP.NET Core

## 1.什么是ASP.NET Core?

> 1. ASP.NET Core是.NET中做Web开发的框架；
> 2. ASP.NET Core MVC是传统的开发网站的技术；
> 3. ASP.NET Core Web API：前后端分离、多端开发；
> 4. ASP.NET Core MVC其实包含Web API，Web API其实是MVC的一部分，但是平时都称之为两个部分；
> 5. 侧重Web API，现在主流是Web API，MVC正在淡化；
> 6. 需要有Html、JavaScript的基础，需要了解Http协议。

## 2.ASP.NET Core MVC

> 1. 模型（Model）、视图（View）和控制器（Controller）,控制器由Controller类实现，视图一般是扩展名为cshtml的文件，而模型则是只有属性的普通C#类。
> 2. 控制器类的名字一般以Controller结尾，并且被放到Controllers文件夹下。控制器的名字为控制器的类名去掉Controller。
> 3. 视图一般被放到Views文件夹下的控制器名字的文件夹下。
> 4. 视图→浏览器端提交的请求→模型→控制器→处理→模型→视图。渲染：Render。

## 3.ASP.NET Core Web API入门

> 1. 什么是结构化的Http接口。Json。
> 2. Web API项目的搭建。
> 3. Web API项目没有Views文件夹。
> 4. 运行项目，解读代码结构。
> 5. 【启用OpenAPI支持】→swagger，在界面上进行接口的测试。

## 4.ASP.NET Core前后端分离开发

### 1.传统MVC开发模式：

> 前后端的代码被放到同一个项目中，前端人员负责编写页面的模板，而后端开发人员负责编写控制器和模型的代码并且“套模板”。缺点：互相依赖；耦合性强；责任划分不清。

### 2.主流的“前后端分离” ：

> 前端开发人员和后端开发人员分别负责前端和后端代码的开发，各自在自己的项目中进行开发；后端人员只写Web API接口，页面由前端人员负责。

### 3.为什么“前后端分离” 更流行以及优缺点?

> 需求变动越来越大、交付周期越来越短、多端支持。
> 优点：独立开发，不互相依赖；耦合性低；责任划分清晰；前后端分别部署，可以针对性运维（扩容等）。
> 缺点：对团队的沟通能力要求更高，提前沟通好接口和通知接口变更；不利于SEO（可以用“服务器端渲染”SSR）；对运维要求更高。

## 5.什么是Rest

> Web API两种风格：面向过程（RPC）、面向REST（REST）
>
> RPC：“控制器/操作方法“的形式把服务器端的代码当成方法去调用。把HTTP当成传输数据的通道，不关心HTTP谓词。通过QueryString、请求报文体给服务器传递数据。状态码。比如：/Persons/GetAll、/Persons/GetById?id=8、/Persons/Update、/Persons/DeleteById/8。
> REST：按照HTTP的语义来使用HTTP协议：
>
> 1. URL用于资源的定位：/user/888、/user/888/orders；
> 2. HTTP谓词：GET、POST（新增）、PUT（整体更新）、DELETE、PATCH（局部更新）等；
> 3. 什么是“幂等”，举例？DELETE、PUT、GET是幂等的，POST不幂等；
> 4. GET的响应可以被缓存；
> 5. 服务器端要通过状态码来反映资源获取的结果：404、403（没有权限）、201（新增成功）。
>
> RPC：业务驱动，自然。 REST：要求开发人员对REST原则更了解、并且有更多的设计能力。

### 1.Restful的优缺点

> REST的优点：
> 1、通过URL对资源定位，语义更清晰；
> 2、通过HTTP谓词表示不同的操作，接口自描述；
> 3、可以对GET、PUT、DELETE请求进行重试；
> 4、可以用GET请求做缓存；
> 5、通过HTTP状态码反映服务器端的处理结果，统一错误处理机制。 6、网关等可以分析请求处理结果。
>
>
> REST的缺点： 1、真实系统中的资源非常复杂，很难清晰地进行资源的划分，对技术人员的业务和技术水平要求高。
> 2、不是所有的操作都能简单地对应到确定的HTTP谓词中。 3、系统的进化可能会改变幂等性。 4、通过URL进行资源定位不符合中文用户的习惯。
> 5、HTTP状态码个数有限。 6、有些环节会篡改非200响应码的响应报文。 7、有的客户端不支持PUT、DELETE请求。
>
> 选择： 1、REST是学术化的概念，仅供参考。为什么AWS、ES等比较RESTful。为什么阿里、腾讯等很多系统不RESTful？
> 2、根据公司情况，进行REST的选择和裁剪。

### 2.Restful中如何传递参数

> HTTP传递参数的三种方式： URL(资源定位)：适合定位；长度限制。 QueryString(URL之外的额外数据)：灵活；长度限制。
> 请求报文体(供PUT、POST提供数据)：灵活；长度不限制；不支持GET、Delete。

> 实施指南: 
> 1）对于保存、更新类的请求POST、PUT请求，把全部参数都放到请求报文体中；
> 2）对于DELETE请求，要传递的参数就是一个资源的id，因此把参数放到QueryString中即可；
> 3）对于GET请求，一般参数的内容都不会太长，因此统一通过QueryString传递参数就可以。对于极少数参数内容超过URL限制的请求，由于GET、PUT请求都是幂等的，因此我们把请求改成通过PUT请求，然后通过报文体来传递参数。

## 6.ASP.NETCore如何返回状态码

## 6.ASP.NET Core 教程

### 1.简介

> ASP.NET Core 是一个跨平台的高性能开源框架，用于生成启用云且连接 Internet 的新式应用。
>
> 使用 ASP.NET Core，可以： 生成 Web 应用和服务、物联网 (IoT) 应用和移动后端。 在 Windows、macOS 和
> Linux 上使用喜爱的开发工具。 部署到云或本地。 在 .NET Core 上运行。

### 2.为何选择 ASP.NET Core

> 数百万开发人员在使用或使用过 ASP.NET 4.x 创建 Web 应用。 ASP.NET Core 是对 ASP.NET 4.x的重新设计，其中包括体系结构上的更改，产生了更精简、更模块化的框架。

> ASP.NET Core 具有如下优点：
>
> - 生成 Web UI 和 Web API 的统一场景。
> - 针对可测试性进行构建。 
> - Razor Pages 可以使基于页面的编码方式更简单高效。
>   Blazor 允许在浏览器中使用 C# 和 JavaScript。 共享全部使用 .NET 编写的服务器端和客户端应用逻辑。
> - 能够在Windows、macOS 和 Linux 上进行开发和运行。 开放源代码和以社区为中心。 集成新式客户端框架和开发工作流。 
> - 支持使用gRPC 托管远程过程调用 (RPC)。
> - 基于环境的云就绪配置系统。 
> - 内置依赖项注入。 
> - 轻型的高性能模块化 HTTP 请求管道。
> - 能够托管于以下各项：
>   - Kestrel 
>    - IIS 
>     - HTTP.sys 
>     - Nginx 
>     - Apache 
>     - Docker 并行版本控制。
>      - 简化新式 Web
>    - 开发的工具。
> - 

### 3.Web应用

> 在本教程结束时，你将拥有一个管理电影数据库的 Razor Pages Web 应用。

#### 1.Razor页面

##### 1.入门

> 本教程是系列教程中的第一个教程，介绍生成 ASP.NET Core Razor 页面 Web 应用的基础知识。

###### 1.创建 Razor 页面 Web 应用

> 1. 首先打开VS2022，创建一个ASP.NET Core Web应用， 如下图：

 

![在这里插入图片描述](https://img-blog.csdnimg.cn/d99591ee8f9d4e52bb7d261f9c6fd6bb.png)

> 2. 项目结构如下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/5b5bef03ba14494bbf8b8547191ce727.png)

###### 2.Pages 文件夹

>  Pages 文件夹包含 Razor 页面和支持文件。 每个 Razor 页面都是一对文件：
>  	一个 .cshtml 文件，其中包含使用 Razor 语法的 C# 代码的 HTML 标记。
>  	一个 .cshtml.cs 文件，其中包含处理页面事件的 C# 代码。
>  	支持文件的名称以下划线开头。 例如，_Layout.cshtml 文件可配置所有页面通用的 UI 元		素。 _Layout.cshtml 设置页面顶部的导航菜单和页面底部的版权声明。

###### 2.wwwroot 文件夹

> wwwroot 文件夹包含静态资产，如 HTML 文件、JavaScript 文件和 CSS 文件。

###### 3.appsettings.json

>appsettings.json包含配置数据，如连接字符串。

###### 4.Program.cs

> Program.cs包含以下代码：

```csharp
namespace RazorPagesMovie
{
	public class Program
	{
		public static void Main(string[] args)
		{
			var builder = WebApplication.CreateBuilder(args);

			// Add services to the container.
			builder.Services.AddRazorPages();

			var app = builder.Build();

			// Configure the HTTP request pipeline.
			if (!app.Environment.IsDevelopment())
			{
				app.UseExceptionHandler("/Error");
				// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
				app.UseHsts();
			}

			app.UseHttpsRedirection();
			app.UseStaticFiles();

			app.UseRouting();

			app.UseAuthorization();

			app.MapRazorPages();

			app.Run();
		}
	}
}
```

> 以下代码片段会创建一个带有预配置默认值的 WebApplicationBuilder，向依赖关系注入 (DI) 容器添加 Razor
> Pages 支持，并生成应用：

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorPages();

var app = builder.Build();
```

> 开发人员异常页默认启用，并提供有关异常的有用信息。 生产应用不得在开发模式中运行，原因是开发人员异常页可能会泄露敏感信息。
>
> 下面的代码会将异常终结点设置为 /Error，并且当应用未在开发模式中运行时，启用 HTTP 严格传输安全协议 (HSTS)：

```csharp
// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}
```

> 例如，当应用在生产或测试模式中时，会运行前面的代码。
>
>
> 下列代码会启用各种中间件：
>
> - app.UseHttpsRedirection();：将 HTTP 请求重定向到 HTTPS。
> - app.UseStaticFiles();：使能够提供 HTML、CSS、映像和 JavaScript 等静态文件。 有关详细信息，请参阅
> - ASP.NET Core 中的静态文件。 app.UseRouting();：向中间件管道添加路由匹配。 有关详细信息，请参阅
> - ASP.NET Core 中的路由 app.MapRazorPages();：为 Razor Pages 配置终结点路由。
> - app.UseAuthorization();：授权用户访问安全资源。 此应用不使用授权，因此可删除此行。 - app.Run();：运行应用。

##### 2.添加模型

> 在本教程中，添加了用于管理数据库中的电影的类。 
> 应用程序的模型类使用 Entity Framework Core (EF Core) 来处理数据库。
> EF Core 是一种对象关系映射器 (O/RM)，可简化数据访问。 首先要编写模型类，然后 EF Core 将创建数据库。
> 模型类称为 POCO 类（源自“简单传统 CLR 对象”），因为它们与 EF Core 没有任何依赖关系。 它们定义数据库中存储的数据属性。

###### 1.添加数据模型

> 新建Models文件夹，并添加一个类名为Movie，如下图：
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/2e173373d16146aaa00597864656065a.png)

```csharp
using System.ComponentModel.DataAnnotations;

namespace RazorPagesMovie.Models
{
	public class Movie
	{
		public int Id { get; set; }//数据库需要 ID 字段以获取主键。

		public string? Title { get; set; }//string 后的问号表示属性可为空。

		[DataType(DataType.Date)]//[DataType] 属性，用于指定 ReleaseDate 属性中的数据类型。 通过此特性：用户无需在日期字段中输入时间信息,仅显示日期，而非时间信息。
		public DateTime ReleaseDate { get; set; }

		public string? Genre { get; set; }

		public decimal Price { get; set; }
	}
}

```

###### 2.搭建“电影”模型的基架

> 接下来，将搭建“电影”模型的基架。 确切地说，基架工具将生成页面，用于对“电影”模型执行创建、读取、更新和删除 (CRUD) 操作。

> 创建“Pages/Movies”文件夹并右键单击 Pages/Movies 文件夹 >“添加”>“新搭建基于基架的项目”。，如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/d13e5520322242d88e3f198d0ad4346b.png)

> 依次选择“使用实体框架的 Razor Pages (CRUD)”>“添加

![在这里插入图片描述](https://img-blog.csdnimg.cn/6fc86357612a495c9d0dbfa175695410.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/3810a132a83943c6b5e98e8c18672f9c.png)

> appsettings.json 文件通过用于连接到本地数据的连接字符串进行更新。

###### 3.创建和更新的文件

> 在搭建基架时，会创建以下文件：
> Pages/Movies：“创建”、“删除”、“详细信息”、“编辑”和“索引”。
> Data/RazorPagesMovieContext.cs

> ASP.NET Core 通过依赖关系注入进行生成。 在应用程序启动过程中通过依赖关系注入注册相关服务（例如 EF Core数据库上下文）。 需要这些服务（如 Razor Pages）的组件通过构造函数参数提供。
> 基架工具自动创建数据库上下文并将其注册到依赖关系注入容器。基架进程将以下红色矩形框中代码添加到 Program.cs 文件中：

![在这里插入图片描述](https://img-blog.csdnimg.cn/ff5ce89b164f487db27777cf4ac32ca1.png)

###### 4.使用 EF 的迁移功能创建初始数据库架构

> Entity Framework Core 中的迁移功能提供了一种方法来执行以下操作：
>
> 创建初始数据库架构。 
> 以增量的方式更新数据库架构，使其与应用的数据模型保持同步。 保存数据库中的现有数据。

> 在此部分中，程序包管理器控制台 (PMC) 窗口用于： 
> 添加初始迁移。 
> 使用初始迁移来更新数据库。

> 在“工具”菜单中，选择“NuGet 包管理器”>“包管理器控制台”。

![在这里插入图片描述](https://img-blog.csdnimg.cn/83d3db33f32744c193db39adc69bd341.png)

> 在 PMC 中，输入以下命令：

```bash
Add-Migration InitialCreate
Update-Database
```

> 1. Add-Migration 命令生成用于创建初始数据库架构的代码。 该架构基于在 DbContext 中指定的模型。 InitialCreate 参数用于为迁移命名。 可以使用任何名称，但是按照惯例，会选择可说明迁移的名称。
> 2. Update-Database 命令在尚未应用的迁移中运行 Up 方法。 在这种情况下，命令在用于创建数据库的 Migrations/< time-stamp >_InitialCreate.cs 文件中运行 Up 方法。

> 数据上下文 RazorPagesMovieContext：
>
> 派生自 Microsoft.EntityFrameworkCore.DbContext。
> 指定数据模型中包含哪些实体。
> 为 Movie模型协调 EF Core 功能，例如“创建”、“读取”、“更新”和“删除”。

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using RazorPagesMovie.Models;

namespace RazorPagesMovie.Data
{
    public class RazorPagesMovieContext : DbContext
    {
        public RazorPagesMovieContext (DbContextOptions<RazorPagesMovieContext> options)
            : base(options)
        {
        }

        public DbSet<RazorPagesMovie.Models.Movie> Movie { get; set; } = default!;
    }
}

```

> 前面的代码为实体集创建 DbSet<Movie> 属性。 在实体框架术语中，实体集通常与数据表相对应。 实体对应表中的行。
>
> 通过调用 DbContextOptions 对象中的一个方法将连接字符串名称传递到上下文。 进行本地开发时，配置系统在appsettings.json 文件中读取连接字符串。

###### 5.测试应用

> 接下来，运行应用并将 /Movies 追加到浏览器中的 URL (http://localhost:port/movies)并测试“新建”链接
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/d0df70ace4f74a238c58bd9e74a89843.png)
> 测试“编辑”、“详细信息”和“删除”链接。

##### 3.基架

> 本教程介绍上一教程中通过搭建基架创建的 Razor 页面。

###### 1.“创建”、“删除”、“详细信息”和“编辑”页面

检查 Pages/Movies/Index.cshtml.cs 页面模型：

```csharp
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.EntityFrameworkCore;
using RazorPagesMovie.Models;

namespace RazorPagesMovie.Pages.Movies;

public class IndexModel : PageModel
{
    private readonly RazorPagesMovie.Data.RazorPagesMovieContext _context;

    public IndexModel(RazorPagesMovie.Data.RazorPagesMovieContext context)
    {
        _context = context;
    }

    public IList<Movie> Movie { get;set; }  = default!;

    public async Task OnGetAsync()
    {
        if (_context.Movie != null)
        {
            Movie = await _context.Movie.ToListAsync();
        }
    }
}
```

> Razor 页面派生自 PageModel。 按照约定，PageModel 派生的类称为 PageNameModel。
> 例如，“索引”页命名为 IndexModel。

> 此构造函数使用依赖关系注入将 RazorPagesMovieContext 添加到页面：

> 对页面发出 GET 请求时，OnGetAsync 方法向 Razor 页面返回影片列表。 OnGetAsync 或 OnGet 在 Razor 页面上调用，以初始化该页面的状态。 在这种情况下，OnGetAsync 将获得影片列表并显示出来。

> **当 OnGet 返回 void 或 OnGetAsync 返回 Task 时，不使用任何返回语句。** 例如，检查 Privacy 页面：

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace RazorPagesMovie.Pages
{
    public class PrivacyModel : PageModel
    {
        private readonly ILogger<PrivacyModel> _logger;

        public PrivacyModel(ILogger<PrivacyModel> logger)
        {
            _logger = logger;
        }

        public void OnGet()
        {
        }
    }
}
```

> 当返回类型是 IActionResult 或 Task<IActionResult> 时，必须提供返回语句。
> 例如，Pages/Movies/Create.cshtml.cs OnPostAsync 方法：

```csharp
public async Task<IActionResult> OnPostAsync()
{
  if (!ModelState.IsValid)
    {
        return Page();
    }

    _context.Movie.Add(Movie);
    await _context.SaveChangesAsync();

    return RedirectToPage("./Index");
}
```

> 检查 Pages/Movies/Index.cshtmlRazor 页面：

```html
@page
@model RazorPagesMovie.Pages.Movies.IndexModel

@{
    ViewData["Title"] = "Index";
}

<h1>Index</h1>

<p>
    <a asp-page="Create">Create New</a>
</p>
<table class="table">
    <thead>
        <tr>
            <th>
                @Html.DisplayNameFor(model => model.Movie[0].Title)
            </th>
            <th>
                @Html.DisplayNameFor(model => model.Movie[0].ReleaseDate)
            </th>
            <th>
                @Html.DisplayNameFor(model => model.Movie[0].Genre)
            </th>
            <th>
                @Html.DisplayNameFor(model => model.Movie[0].Price)
            </th>
            <th></th>
        </tr>
    </thead>
    <tbody>
@foreach (var item in Model.Movie) {
        <tr>
            <td>
                @Html.DisplayFor(modelItem => item.Title)
            </td>
            <td>
                @Html.DisplayFor(modelItem => item.ReleaseDate)
            </td>
            <td>
                @Html.DisplayFor(modelItem => item.Genre)
            </td>
            <td>
                @Html.DisplayFor(modelItem => item.Price)
            </td>
            <td>
                <a asp-page="./Edit" asp-route-id="@item.Id">Edit</a> |
                <a asp-page="./Details" asp-route-id="@item.Id">Details</a> |
                <a asp-page="./Delete" asp-route-id="@item.Id">Delete</a>
            </td>
        </tr>
}
    </tbody>
</table>
```

> **Razor 可以从 HTML 转换为 C# 或 Razor 特定标记。 当 @ 符号后跟 Razor 保留关键字时，它会转换为 Razor特定标记，否则会转换为 C#。**

###### 2.@page 指令

>  "@page"   Razor 指令将文件转换为一个 MVC 操作，这意味着它可以处理请求。 @page 必须是页面上的第一个Razor 指令。 @page 和 @model 是转换为 Razor 特定标记的示例。

###### 3.@model 指令

```html
@page
@model RazorPagesMovie.Pages.Movies.IndexModel
```

###### 4.@model 指令

> @model 指令指定传递到 Razor 页面的模型类型。 在前面的示例中，@model 行使 PageModel 派生的类可用于 Razor 页面。 在页面上的 @Html.DisplayNameFor 和 @Html.DisplayForHTML
> 帮助程序中使用该模型。
>
> 检查以下 HTML 帮助程序中使用的 Lambda 表达式：

```html
@Html.DisplayNameFor(model => model.Movie[0].Title)
```

> DisplayNameFor HTML 帮助程序检查 Lambda 表达式中引用的 Title 属性来确定显示名称。 检查 Lambda 表达式（而非求值）。 这意味着当 model、model.Movie 或 model.Movie[0] 为 null
> 或为空时，不会存在任何访问冲突。 对 Lambda 表达式求值时（例如，使用 @Html.DisplayFor(modelItem => item.Title)），将求得该模型的属性值。

###### 5.布局页

> 选择菜单链接（“RazorPagesMovie”、“Home”和“Privacy”）。 每页显示相同的菜单布局。 菜单布局在Pages/Shared/_Layout.cshtml 文件中实现。

> 打开并检查 Pages/Shared/_Layout.cshtml 文件。

> 布局模板允许 HTML 容器具有如下布局：
> 在一个位置指定。
> 应用于站点中的多个页面。

> 查找 @RenderBody() 行。 RenderBody 是显示全部页面专用视图的占位符，已包装在布局页中。 例如，选择 Privacy
> 链接后，Pages/Privacy.cshtml 视图在 RenderBody 方法中呈现。

###### 6.ViewData 和布局

> 考虑来自 Pages/Movies/Index.cshtml 文件的以下标记：

```html
@page
@model RazorPagesMovie.Pages.Movies.IndexModel

@{
    ViewData["Title"] = "Index";
}
```


> **PageModel 基类包含 ViewData 字典属性，可用于将数据传递到某个视图。 可以使用键值模式将对象添加到 ViewData字典。 在前面的示例中，Title 属性被添加到 ViewData 字典。**

> Title 属性用于 Pages/Shared/_Layout.cshtml 文件。 以下标记显示 _Layout.cshtml
> 文件的前几行。

###### 7.更新布局

> 更改 Pages/Shared/_Layout.cshtml 文件中的 <title> 元素以显示 Movie 而不是
> RazorPagesMovie。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@ViewData["Title"] - Movie</title>
```

> 查找 Pages/Shared/_Layout.cshtml 文件中的以下定位点元素。

```html
<a class="navbar-brand" asp-area="" asp-page="/Index">RazorPagesMovie</a>
```

> 将前面的元素替换为以下标记：

```html
<a class="navbar-brand" asp-page="/Movies/Index">RpMovie</a>
```

> 前面的定位点元素是一个标记帮助程序。 此处它是定位点标记帮助程序。 asp-page="/Movies/Index" 标记帮助程序属性和值可以创建指向 /Movies/IndexRazor 页面的链接。 asp-area 属性值为空，因此在链接中未使用区域。
>
> 保存所做的更改，并通过选择“RpMovie”链接测试应用。
> 测试“Home”、“RpMovie”、“创建”、“编辑”和“删除”链接。 每个页面都设置有标题，可以在浏览器选项卡中看到标题。将某个页面加入书签时，标题用于该书签。

> 在 Pages/_ViewStart.cshtml 文件中设置 Layout 属性：

```html
@{
    Layout = "_Layout";
}
```

> **前面的标记针对 Pages 文件夹下的所有 Razor 文件将布局文件设置为Pages/Shared/_Layout.cshtml。**

###### 8.“创建”页面模型

> 检查 Pages/Movies/Create.cshtml.cs 页面模型：

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using RazorPagesMovie.Models;

namespace RazorPagesMovie.Pages.Movies
{
    public class CreateModel : PageModel
    {
        private readonly RazorPagesMovie.Data.RazorPagesMovieContext _context;

        public CreateModel(RazorPagesMovie.Data.RazorPagesMovieContext context)
        {
            _context = context;
        }

        public IActionResult OnGet()
        {
            return Page();
        }

        [BindProperty]
        public Movie Movie { get; set; } = default!;
        

        // To protect from overposting attacks, see https://aka.ms/RazorPagesCRUD
        public async Task<IActionResult> OnPostAsync()
        {
          if (!ModelState.IsValid || _context.Movie == null || Movie == null)
            {
                return Page();
            }

            _context.Movie.Add(Movie);
            await _context.SaveChangesAsync();

            return RedirectToPage("./Index");
        }
    }
}
```

> OnGet 方法初始化页面所需的任何状态。 “创建”页没有任何要初始化的状态，因此返回 Page。 在本教程的后面部分中，将介绍 OnGet
> 初始化状态的示例。 Page 方法创建用于呈现 Create.cshtml 页的 PageResult 对象。

> Movie 属性使用 [BindProperty] 特性来选择加入模型绑定。 当“创建”表单发布表单值时，ASP.NET Core
> 运行时将发布的值绑定到 Movie 模型。

> 当页面发布表单数据时，运行 OnPostAsync 方法：

```csharp
public async Task<IActionResult> OnPostAsync()
{
  if (!ModelState.IsValid)
    {
        return Page();
    }

    _context.Movie.Add(Movie);
    await _context.SaveChangesAsync();

    return RedirectToPage("./Index");
}
```

> 如果不存在任何模型错误，将重新显示表单，以及发布的任何表单数据。 在发布表单前，可以在客户端捕获到大部分模型错误。
> 模型错误的一个示例是，发布的日期字段值无法转换为日期。 本教程后面讨论了客户端验证和模型验证。

> 如果没有模型错误： 
> 将保存数据。
> 浏览器将重定向到“索引”页。

###### 9.“创建 Razor”页面

> 检查 Pages/Movies/Create.cshtmlRazor 页面文件：

```html
@page
@model RazorPagesMovie.Pages.Movies.CreateModel

@{
    ViewData["Title"] = "Create";
}

<h1>Create</h1>

<h4>Movie</h4>
<hr />
<div class="row">
    <div class="col-md-4">
        <form method="post">
            <div asp-validation-summary="ModelOnly" class="text-danger"></div>
            <div class="form-group">
                <label asp-for="Movie.Title" class="control-label"></label>
                <input asp-for="Movie.Title" class="form-control" />
                <span asp-validation-for="Movie.Title" class="text-danger"></span>
            </div>
            <div class="form-group">
                <label asp-for="Movie.ReleaseDate" class="control-label"></label>
                <input asp-for="Movie.ReleaseDate" class="form-control" />
                <span asp-validation-for="Movie.ReleaseDate" class="text-danger"></span>
            </div>
            <div class="form-group">
                <label asp-for="Movie.Genre" class="control-label"></label>
                <input asp-for="Movie.Genre" class="form-control" />
                <span asp-validation-for="Movie.Genre" class="text-danger"></span>
            </div>
            <div class="form-group">
                <label asp-for="Movie.Price" class="control-label"></label>
                <input asp-for="Movie.Price" class="form-control" />
                <span asp-validation-for="Movie.Price" class="text-danger"></span>
            </div>
            <div class="form-group">
                <input type="submit" value="Create" class="btn btn-primary" />
            </div>
        </form>
    </div>
</div>

<div>
    <a asp-page="Index">Back to List</a>
</div>

@section Scripts {
    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}
}
```

> **<form method="post"> 元素是一个表单标记帮助程序。 表单标记帮助程序会自动包含防伪令牌。**

> 基架引擎在模型中为每个字段（ID 除外）创建 Razor 标记，如下所示：

```html
<div asp-validation-summary="ModelOnly" class="text-danger"></div>
<div class="form-group">
    <label asp-for="Movie.Title" class="control-label"></label>
    <input asp-for="Movie.Title" class="form-control" />
    <span asp-validation-for="Movie.Title" class="text-danger"></span>
</div>
```

> 验证标记帮助程序（<div asp-validation-summary 和 <span asp-validation-for）显示验证错误。 本系列后面的部分将更详细地讨论有关验证的信息。

> 标签标记帮助程序 (< label asp-for="Movie.Title" class="control-label">< /label >)生成标签描述和 Title 属性的 [for] 特性。

> 输入标记帮助程序 (< input asp-for="Movie.Title" class="form-control">) 使用 DataAnnotations 属性并在客户端生成 jQuery 验证所需的 HTML 属性。

##### 4.使用数据库

> azorPagesMovieContext 对象处理连接到数据库并将 Movie 对象映射到数据库记录的任务。

> ASP.NET Core 配置系统会读取 键。 进行本地开发时，配置从 appsettings.json 文件获取连接字符串。

```bash
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "RazorPagesMovieContext": "Server=(localdb)\\mssqllocaldb;Database=RazorPagesMovieContext-bc;Trusted_Connection=True;MultipleActiveResultSets=true"
  }
}
```

###### 1.SQL Server Express LocalDB

> LocalDB 是轻型版的 SQL Server Express 数据库引擎，以程序开发为目标。 LocalDB 作为按需启动并在用户模式下运行的轻量级数据库没有复杂的配置。 默认情况下，LocalDB 数据库在 C:\Users\< user >\目录下创建 *.mdf 文件。


> 1. 从“视图”菜单中，打开“SQL Server 对象资源管理器”(SSOX) 。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0e90d1dad6a14465834aed6faf18fae6.png)

> 2. 右键单击 Movie 表，然后选择“视图设计器”
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/8f1d3ed36ad246b4bf9a512220e10842.png)

> 请注意 ID 旁边的密钥图标。 默认情况下，EF 为该主键创建一个名为 ID 的属性。

![在这里插入图片描述](https://img-blog.csdnimg.cn/56f5520350754027a0918e5d993a7434.png)

> 3. 右键单击 Movie 表，然后选择“查看数据”：

![右键单击 Movie 表，然后选择“查看数据”：](https://img-blog.csdnimg.cn/13690a44253f4b6893a4df673646d1f1.png)

###### 2.设定数据库种子

> 使用以下代码在 Models 文件夹中创建一个名为 SeedData 的新类：

```csharp
using Microsoft.EntityFrameworkCore;
using RazorPagesMovie.Data;

namespace RazorPagesMovie.Models;

public static class SeedData
{
    public static void Initialize(IServiceProvider serviceProvider)
    {
        using (var context = new RazorPagesMovieContext(
            serviceProvider.GetRequiredService<
                DbContextOptions<RazorPagesMovieContext>>()))
        {
            if (context == null || context.Movie == null)
            {
                throw new ArgumentNullException("Null RazorPagesMovieContext");
            }

            // Look for any movies.
            if (context.Movie.Any())
            {
                return;   // DB has been seeded
            }

            context.Movie.AddRange(
                new Movie
                {
                    Title = "When Harry Met Sally",
                    ReleaseDate = DateTime.Parse("1989-2-12"),
                    Genre = "Romantic Comedy",
                    Price = 7.99M
                },

                new Movie
                {
                    Title = "Ghostbusters ",
                    ReleaseDate = DateTime.Parse("1984-3-13"),
                    Genre = "Comedy",
                    Price = 8.99M
                },

                new Movie
                {
                    Title = "Ghostbusters 2",
                    ReleaseDate = DateTime.Parse("1986-2-23"),
                    Genre = "Comedy",
                    Price = 9.99M
                },

                new Movie
                {
                    Title = "Rio Bravo",
                    ReleaseDate = DateTime.Parse("1959-4-15"),
                    Genre = "Western",
                    Price = 3.99M
                }
            );
            context.SaveChanges();
        }
    }
}
```

> 如果数据库中有任何电影，则会返回种子初始值设定项，并且不会添加任何电影。

```csharp
if (context.Movie.Any())
{
    return;
}
```

###### 2.添加种子初始值设定项

> 将下面的代码更新到 Program.cs：

```csharp
using (var scope = app.Services.CreateScope())
{
    var services = scope.ServiceProvider;

    SeedData.Initialize(services);
}
```

如图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/f388aa96bb414ef49ae4a9ffc5f27592.png)

> 在上述代码中，修改了 Program.cs 来执行以下操作：
>
> 从依赖注入 (DI) 容器中获取数据库上下文实例。
> 调用 seedData.Initialize 方法，并向其传递数据库上下文实例。
> Seed 方法完成时释放上下文。 using 语句将确保释放上下文。

>  未运行 Update-Database 时出现以下异常：
>
>  SqlException: Cannot open database "RazorPagesMovieContext-" requested by the login. The login failed. Login failed for user 'user name'.

###### 3.测试应用

> 删除数据库中的所有记录，使种子方法运行。 停止并启动应用以设定数据库种子。 如果数据库未设定种子，请在 if(context.Movie.Any()) 上放置断点并单步执行代码。

> 应用将显示设定为种子的数据：

![在这里插入图片描述](https://img-blog.csdnimg.cn/adf67d55316940878a50e7351f9bd933.png)

##### 5.更新生成的页面

> 构架的电影应用有个不错的开始，但是展示效果还不够理想。 ReleaseDate 应是两个词 (Release Date)。

###### 1.更新模型

> 使用以下突出显示的代码更新 Models/Movie.cs

![在这里插入图片描述](https://img-blog.csdnimg.cn/310db106b1614a0d901dff4f35830adc.png)

> 在前面的代码中：
>
> [Column(TypeName = "decimal(18, 2)")] 数据注释使 Entity Framework Core 可以将 Price 正确映射到数据库中的货币。 有关详细信息，请参阅数据类型。
> [Display] 属性指定字段的显示名称。 在前面的代码中，是Release Date 而不是 ReleaseDate。
> [DataType] 属性指定数据的类型 (Date)。此字段中存储的时间信息不显示。

> 浏览到 Pages/Movies，并将鼠标悬停在“编辑”链接上以查看目标 URL。
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/21857d31ddd14451a605c8d22b622dde.png)

> “编辑”、“详细信息”和“删除”链接是在 Pages/Movies/Index.cshtml 文件中由定位标记帮助程序生成的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/fcb6110447904bd9bb9265647846ac9e.png)

> 标记帮助程序使服务器端代码可以在 Razor 文件中参与创建和呈现 HTML 元素。

> 在前面的代码中，定位标记帮助程序从 Razor 页面（路由是相对的）、asp-page 和路由标识符 (asp-route-id) 动态生成HTML href 特性值。 有关详细信息，请参阅页面的 URL 生成。

> 在浏览器中使用“查看源”来检查生成的标记。 生成的 HTML 的一部分如下所示：

```html
<td>
  <a href="/Movies/Edit?id=1">Edit</a> |
  <a href="/Movies/Details?id=1">Details</a> |
  <a href="/Movies/Delete?id=1">Delete</a>
</td>
```

> 动态生成的链接通过查询字符串传递电影 ID。 例如，https://localhost:5001/Movies/Details?id=1中的 ?id=1。

###### 2.添加路由模板

> 更新“编辑”、“详细信息”和“删除”Razor 页面以使用 {id:int} 路由模板。 将上述每个页面的页面指令从 @page 更改为 @page "{id:int}"。 运行应用，然后查看源。

> 生成的 HTML 会将 ID 添加到 URL 的路径部分：

```html
<td>
  <a href="/Movies/Edit/1">Edit</a> |
  <a href="/Movies/Details/1">Details</a> |
  <a href="/Movies/Delete/1">Delete</a>
</td>
```

> 如果对具有 {id:int} 路由模板的页面进行的请求中不包含整数，则返回 HTTP 404（未找到）错误。例如，https://localhost:5001/Movies/Details 返回 404 错误。 若要使 ID 可选，请将 ?追加到路由约束：

```html
@page "{id:int?}"
```

> 测试 @page "{id:int?}" 的行为：
>
> 1. 在 Pages/Movies/Details.cshtml 中将 page 指令设置为 @page "{id:int?}"。
> 2. 在Pages/Movies/Details.cshtml.cs 中的 public async Task< IActionResult > OnGetAsync(int? id) 中设置断点。
> 3. 导航到 https://localhost:5001/Movies/Details/。

> 使用 @page "{id:int}" 指令时，永远不会命中断点。 路由引擎返回 HTTP 404。 使用 @page
> "{id:int?}" 时，OnGetAsync 方法返回 NotFound (HTTP 404)：

![在这里插入图片描述](https://img-blog.csdnimg.cn/cf10e05dfe0144f09dabb0835d06e3e0.png)

###### 3.查看并发异常处理

> 查看 Pages/Movies/Edit.cshtml.cs 文件中的 OnPostAsync 方法：

```csharp
public async Task<IActionResult> OnPostAsync()
{
    if (!ModelState.IsValid)
    {
        return Page();
    }

    _context.Attach(Movie).State = EntityState.Modified;

    try
    {
        await _context.SaveChangesAsync();
    }
    catch (DbUpdateConcurrencyException)
    {
        if (!MovieExists(Movie.Id))
        {
            return NotFound();
        }
        else
        {
            throw;
        }
    }

    return RedirectToPage("./Index");
}

private bool MovieExists(int id)
{
  return _context.Movie.Any(e => e.Id == id);
}
```

> 当一个客户端删除电影并且另一个客户端对电影发布更改时，前面的代码会检测并发异常。

> 测试 catch 块：
>
> 1. 在 catch (DbUpdateConcurrencyException) 上设置断点。
> 2. 对电影选择“编辑”，进行更改，但不要输入“保存”。 
> 3. 在其他浏览器窗口中，选择同一电影的“删除”链接，然后删除此电影。
> 4. 在之前的浏览器窗口中，将更改发布到电影。

> 生产代码可能要检测并发冲突。

###### 4.发布和绑定审阅

> 检查 Pages/Movies/Edit.cshtml.cs 文件：

```csharp
public class EditModel : PageModel
{
    private readonly RazorPagesMovie.Data.RazorPagesMovieContext _context;

    public EditModel(RazorPagesMovie.Data.RazorPagesMovieContext context)
    {
        _context = context;
    }

    [BindProperty]
    public Movie Movie { get; set; } = default!;

    public async Task<IActionResult> OnGetAsync(int? id)
    {
        if (id == null || _context.Movie == null)
        {
            return NotFound();
        }

        var movie =  await _context.Movie.FirstOrDefaultAsync(m => m.Id == id);
        if (movie == null)
        {
            return NotFound();
        }
        Movie = movie;
        return Page();
    }

    // To protect from overposting attacks, enable the specific properties you want to bind to.
    // For more details, see https://aka.ms/RazorPagesCRUD.
    public async Task<IActionResult> OnPostAsync()
    {
        if (!ModelState.IsValid)
        {
            return Page();
        }

        _context.Attach(Movie).State = EntityState.Modified;

        try
        {
            await _context.SaveChangesAsync();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!MovieExists(Movie.Id))
            {
                return NotFound();
            }
            else
            {
                throw;
            }
        }

        return RedirectToPage("./Index");
    }

    private bool MovieExists(int id)
    {
      return _context.Movie.Any(e => e.Id == id);
    }
```

> 当对 Movies/Edit 页面（例如 https://localhost:5001/Movies/Edit/3）进行 HTTP GET请求时：
>
> OnGetAsync 方法从数据库提取电影并返回 Page 方法。
> Page 方法呈现 Pages/Movies/Edit.cshtmlRazor 页面。 Pages/Movies/Edit.cshtml 文件包含模型指令 @model RazorPagesMovie.Pages.Movies.EditModel，这使电影模型在页面上可用。
> “编辑”表单中会显示电影的值。

> 当发布 Movies/Edit 页面时： 
> 1.此页面上的表单值将绑定到 Movie 属性。 [BindProperty] 特性会启用模型绑定。

```csharp
[BindProperty]
public Movie Movie { get; set; }
```

> 2.如果模型状态中存在错误（例如，ReleaseDate 无法被转换为日期），则会使用已提交的值重新显示表单。

> 3.如果没有模型错误，则电影已保存。

> “索引”、“创建”和“删除”Razor 页面中的 HTTP GET 方法遵循一个类似的模式。 “创建”Razor 页面中的 HTTP POST OnPostAsync 方法遵循的模式类似于“编辑”Razor 页面中的 OnPostAsync 方法所遵循的模式。

##### 6.添加搜索

> 在以下部分中，添加了按流派或名称搜索电影。

> 将以下突出显示的代码添加到 Pages/Movies/Index.cshtml.cs：

![在这里插入图片描述](https://img-blog.csdnimg.cn/14fac39191014cb292160dfbeb15994f.png)

> 在前面的代码中：
>
> SearchString：包含用户在搜索文本框中输入的文本。 SearchString 也有 [BindProperty] 属性。[BindProperty] 会绑定名称与属性相同的表单值和查询字符串。 在 HTTP GET 请求中进行绑定需要[BindProperty(SupportsGet = true)]。 
> Genres：包含流派列表。 Genres 使用户能够从列表中选择一种流派。 SelectList 需要 using
> Microsoft.AspNetCore.Mvc.Rendering; 
> MovieGenre：包含用户选择的特定流派。 例如，“Western”。 
> Genres 和 MovieGenre 会在本教程的后续部分中使用。

> 使用以下代码更新索引页面的 OnGetAsync 方法：

```csharp
public async Task OnGetAsync()
{
    var movies = from m in _context.Movie
                 select m;
    if (!string.IsNullOrEmpty(SearchString))
    {
        movies = movies.Where(s => s.Title.Contains(SearchString));
    }

    Movie = await movies.ToListAsync();
}
```

> 导航到电影页面，并向 URL 追加一个如 ?searchString=Ghost 的查询字符串。 例如
> https://localhost:5001/Movies?searchString=Ghost。 筛选的电影将显示出来。

> 打开 Pages/Movies/Index.cshtml 文件，并添加以下代码中突出显示的标记：

![在这里插入图片描述](https://img-blog.csdnimg.cn/4f74858e24264731999fee68d41a25ab.png)

> HTML < form> 标记使用以下标记帮助程序：
>
> 表单标记帮助程序。 提交表单时，筛选器字符串将通过查询字符串发送到 Pages/Movies/Index 页面。
> 输入标记帮助程序

> 保存更改并测试筛选器。
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/0dfb0c0e9cac4f03935998f88d602224.png)

###### 1.按流派搜索

> 使用以下代码更新索引页面的 OnGetAsync 方法：

```csharp
public async Task OnGetAsync()
{
    // Use LINQ to get list of genres.
    IQueryable<string> genreQuery = from m in _context.Movie
                                    orderby m.Genre
                                    select m.Genre;

    var movies = from m in _context.Movie
                 select m;

    if (!string.IsNullOrEmpty(SearchString))
    {
        movies = movies.Where(s => s.Title.Contains(SearchString));
    }

    if (!string.IsNullOrEmpty(MovieGenre))
    {
        movies = movies.Where(x => x.Genre == MovieGenre);
    }
    Genres = new SelectList(await genreQuery.Distinct().ToListAsync());
    Movie = await movies.ToListAsync();
}
```

> 下面的代码是一种 LINQ 查询，可从数据库中检索所有流派。

```csharp
// Use LINQ to get list of genres.
IQueryable<string> genreQuery = from m in _context.Movie
                                orderby m.Genre
                                select m.Genre;
```

> 流派的 SelectList 是通过投影不包含重复值的流派创建的。

```csharp
Genres = new SelectList(await genreQuery.Distinct().ToListAsync());
```

###### 2.将按流派搜索添加到 Razor 页面

> 更新 Index.cshtml< form > 元素，如以下标记中突出显示的内容所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/56cd48f86c9e4c1394d865e7265b2ba9.png)

> 通过按流派或/和电影标题搜索来测试应用。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ba28028edd5f46ef91a5eebfff46c48d.png)

##### 7.添加新字段

> 在此部分中，Entity Framework Code First 迁移用于：
>
> 将新字段添加到模型。 
> 将新字段架构更改迁移到数据库。 

> 使用 EF Code First 自动创建和跟踪数据库时，Code First 将：
>
> 向数据库添加 __EFMigrationsHistory 表格，以跟踪数据库的架构是否与从生成它的模型类同步。
> 如果该模型类未与数据库同步，则会引发异常。


>  自动验证架构与模型是否同步可以更容易地发现不一致的数据库代码问题。

###### 1.向电影模型添加分级属性

> 1. 打开 Models/Movie.cs 文件并添加 Rating 属性：

![在这里插入图片描述](https://img-blog.csdnimg.cn/aad4ab79e7794ee396452d1ff36f8d90.png)

> 2. 编辑 Pages/Movies/Index.cshtml，并添加 Rating 字段：

![在这里插入图片描述](https://img-blog.csdnimg.cn/cb48f36f603e47af8e287f70a6271bc6.png)

> 3. 使用 Rating 字段更新以下页面：
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/b7d80c9a6ce64a5e9645629d08d9d499.png)
>
> 在数据库更新为包括新字段之前，应用将不会正常工作。 在不更新数据库的情况下运行应用会引发 SqlException： SqlException: Invalid column name 'Rating'.
>
> SqlException 异常是由于更新的 Movie 模型类与数据库的 Movie 表架构不同导致的。 数据库表中没有 Rating 列。

> 可通过几种方法解决此错误：
>
> 1. 让 Entity Framework 自动丢弃并使用新的模型类架构重新创建数据库。
>    此方法在开发周期早期很方便，开发人员可通过它一起快速改进模型和数据库架构。 它的缺点是数据库中的现有数据会丢失。请勿对生产数据库使用此方法！ 在架构更改时丢弃数据库，并使用初始化表达式通过测试数据自动设定数据库种子，这通常是开发应用的有效方式。
> 2. 对现有数据库架构进行显式修改，使它与模型类相匹配。 此方法的优点是可以保留数据。 可以手动或通过创建数据库更改脚本进行此更改。
> 3. 使用Code First 迁移更新数据库架构。 

> 对于本教程，请使用 Code First 迁移。

> 更新 SeedData 类，使它提供新列的值。 示例更改如下所示，但对每个 new Movie 块做出此更改。

###### 2.添加用于评级字段的迁移

> 1. 从“工具”菜单中，选择“NuGet 包管理器”>“包管理器控制台”。
> 2. 在 PMC 中，输入以下命令：

```bash
Add-Migration Rating
Update-Database
```

> Add-Migration 命令会通知框架执行以下操作：
>
> 将 Movie 模型与 Movie 数据库架构进行比较。 
> 创建代码以将数据库架构迁移到新模型。


> 名称“Rating”是任意的，用于对迁移文件进行命名。 为迁移文件使用有意义的名称是有帮助的。


> Update-Database 命令指示框架将架构更改应用到数据库并保留现有数据。

> 删除数据库中的所有记录后，初始化表达式会设定数据库种子，并将包括 Rating 字段。 可以使用浏览器中的删除链接，也可从 SQL Server 对象资源管理器 (SSOX) 进行删除。

> 另一个方案是删除数据库，并使用迁移来重新创建该数据库。 删除 SSOX 中的数据库：
>
> 1. 在 SSOX 中选择数据库。
>
> 2. 右键单击数据库，并选择“删除”。
>
> 3. 检查“关闭现有连接”。
>
> 4. 选择“确定”。
>
> 5. 在 PMC 中更新数据库：

```bash
Update-Database
```

> 运行应用，并验证是否可以创建、编辑和显示具有 Rating 字段的电影。 如果数据库未设定种子，则在 SeedData.Initialize方法中设置断点。

##### 8.添加验证

> 本部分中向 Movie 模型添加了验证逻辑。 每当用户创建或编辑电影时，都会强制执行验证规则。

###### 1.验证

> 软件开发的一个关键原则被称为 DRY（即“不要自我重复”） 。 Razor 页面鼓励进行仅指定一次功能的开发，且功能在整个应用中反映。DRY 可以帮助：
>
> 1. 减少应用中的代码量。 
>    2.使代码更加不易出错，且更易于测试和维护。 


> Razor 页面和实体框架提供的验证支持是 DRY 原则的极佳示例：
>
> 1.  验证规则在模型类中的某处以声明方式指定。
> 2.  规则在应用的所有位置强制执行。

###### 2.将验证规则添加到电影模型

> System.ComponentModel.DataAnnotations 命名空间提供以下内容：
>
> 1. 一组内置验证特性，可通过声明方式应用于类或属性。
> 2. [DataType] 等格式特性，这些特性可帮助进行格式设置，但不提供任何验证。

> 更新 Movie 类以使用内置的 [Required]、[StringLength]、[RegularExpression] 和
> [Range] 验证特性。

```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace RazorPagesMovie.Models;

public class Movie
{
    public int Id { get; set; }

    [StringLength(60, MinimumLength = 3)]
    [Required]
    public string Title { get; set; } = string.Empty;

    // [Display(Name = "Release Date")]
    [DataType(DataType.Date)]
    public DateTime ReleaseDate { get; set; }

    [Range(1, 100)]
    [DataType(DataType.Currency)]
    [Column(TypeName = "decimal(18, 2)")]
    public decimal Price { get; set; }

    [RegularExpression(@"^[A-Z]+[a-zA-Z\s]*$")]
    [Required]
    [StringLength(30)]
    public string Genre { get; set; } = string.Empty;

    [RegularExpression(@"^[A-Z]+[a-zA-Z0-9""'\s-]*$")]
    [StringLength(5)]
    [Required]
    public string Rating { get; set; } = string.Empty;
}
```

> 验证特性指定要对应用这些特性的模型属性强制执行的行为：
>
> 1. [Required] 和 [MinimumLength] 特性指示属性必须具有一个值。 不阻止用户输入空格来满足此验证。
>
> 2. [RegularExpression] 特性用于限制可输入的字符。 在上述代码中，Genre：
>    - 只能使用字母。
>    - 第一个字母必须为大写。 允许使用空格，但不允许使用数字和特殊字符。
>
> 3. RegularExpressionRating：
>    - 要求第一个字符为大写字母。
>    - 允许在后续空格中使用特殊字符和数字。 “PG-13”对“分级”有效，但对于“Genre”无效。
>
> 4. [Range] 特性将值限制在指定的范围内。
>
> 5. [StringLength] 特性可以设置字符串属性的最大长度，以及可选的最小长度。
>
> 6. 从本质上来说，需要值类型（如 decimal、int、float、DateTime），但不需要 [Required] 特性。

> 上述验证规则用于进行演示，它们并不是适用于生产系统的最佳规则。 例如，前面的规则会阻止用户仅使用两个字符输入一部电影，并且不允许 Genre 中有特殊字符。

> 让 ASP.NET Core 强制自动执行验证规则有助于：
>
> 1. 提升应用的可靠性。 
> 2. 减少将无效数据保存到数据库的几率。

###### 3.Razor 页面中的验证错误 UI

> 运行应用并导航到“页面/电影”。
>
> 选择“新建”链接。 使用无效值填写表单。 当 jQuery 客户端验证检测到错误时，会显示一条错误消息。
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/736b2802de42466b85e80285290689aa.png)

###### 4.应用迁移

> 应用于类的 DataAnnotations 会更改架构。 

> 请创建迁移，使架构与模型保持一致。

> 从“工具”菜单中，选择“NuGet 包管理器”>“包管理器控制台”。 在 PMC 中，输入以下命令:

```bash
Add-Migration New_DataAnnotations
Update-Database
```

> Update-Database 运行 New_DataAnnotations 类的 Up 方法。 检查 Up 方法：

```csharp
public partial class NewDataAnnotations : Migration
{
    /// <inheritdoc />
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.AlterColumn<string>(
            name: "Title",
            table: "Movie",
            type: "nvarchar(60)",
            maxLength: 60,
            nullable: false,
            oldClrType: typeof(string),
            oldType: "nvarchar(max)");

        migrationBuilder.AlterColumn<string>(
            name: "Rating",
            table: "Movie",
            type: "nvarchar(5)",
            maxLength: 5,
            nullable: false,
            oldClrType: typeof(string),
            oldType: "nvarchar(max)");

        migrationBuilder.AlterColumn<string>(
            name: "Genre",
            table: "Movie",
            type: "nvarchar(30)",
            maxLength: 30,
            nullable: false,
            oldClrType: typeof(string),
            oldType: "nvarchar(max)");
    }
```

###### 5.发布到 Azure

[将 ASP.NET Core 和 Azure SQL 数据库应用部署到 Azure 应用服务](https://learn.microsoft.com/zh-cn/azure/app-service/tutorial-dotnetcore-sqldb-app)

# 6.ASP.NET Core 中的 Razor Pages 和 Entity Framework Core

> 1. ASP.NET Core 通过依赖关系注入进行生成。 服务（例如 SchoolContext）在应用程序启动期间通过依赖关系注入进行注册。 需要这些服务（如 Razor 页面）的组件通过构造函数参数提供相应服务。因此可在Program.cs类中配置服务相关。

> 2. 通过调用 DbContextOptions 中的一个方法将数据库连接字符串在配置文件中的名称传递给上下文对象。 进行本地开发时，ASP.NET Core 配置系统会从 appsettings.json 或 appsettings.Development.json 文件中读取连接字符串。

> 3. Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore NuGet 包提供 Entity Framework Core 错误页的 ASP.NET Core 中间件。 此中间件有助于检测和诊断 Entity Framework Core 迁移错误。

> 4. AddDatabaseDeveloperPageExceptionFilter 在开发环境中为 EF 迁移错误提供有用的错误信息。

> 5. FirstOrDefaultAsync 读取一个实体。 如果未找到任何内容，则此方法返回 NULL；否则，它将返回满足查询筛选条件的第一行。 FirstOrDefaultAsync 通常是比以下备选方案更好的选择：
>
>   -  SingleOrDefaultAsync - 如果有多个满足查询筛选器的实体，则引发异常。 若要确定查询是否可以返回多行，SingleOrDefaultAsync 会尝试提取多个行。 如果查询只能返回一个实体，就像它在搜索唯一键时一样，那么该额外工作是不必要的。
>   -  FindAsync - 查找具有主键 ( PK) 的实体。 如果具有 PK 的实体正在由上下文跟踪，会返回该实体且不向数据库发出请求。 此方法经过优化，可查找单个实体，但无法通过 FindAsync 调用 Include。 如果需要相关数据，FirstOrDefaultAsync 则是更好的选择。

> 6.  TryUpdateModelAsync 方法更新具有已发布值的字段是一种最佳的安全做法，因为这能阻止过多发布。

> 7. 视图模型还提供了一种防止过度发布的方法。
>    应用程序模型通常称为域模型。 域模型通常包含数据库中对应实体所需的全部属性。 视图模型仅包含 UI 页（例如“创建”页）所需的属性。
>    除视图模型外，某些应用使用绑定模型或输入模型在 Razor Pages 页面模型类和浏览器之间传递数据。

> 8. 开发新应用时，数据模型会频繁更改。 每当模型发生更改时，都无法与数据库进行同步。数据模型每次发生更改时，必须删除该数据库。 下次应用运行时，对 EnsureCreated 的调用将重新创建数据库以匹配新的数据模型。 然后 DbInitializer 类将运行以设定新数据库的种子。


> 9.这种使 DB 与数据模型保持同步的方法非常适用，但需要将应用部署到生产环境的情况除外。 当应用在生产环境中运行时，应用通常会存储需要保留的数据。 每当发生更改（例如添加新列）时，应用都无法在具有测试 DB 的环境下启动。
> EF Core 迁移功能可通过使 EF Core 更新 DB 架构而不是创建新数据库来解决此问题。
> 数据模型更改时，迁移不会删除并重新创建数据库，而是更新架构并保留现有数据。

> 10. 一些EF数据库相关命令：
>
> * 删除数据库：
>   Drop-Database
> * 创建初始迁移并更新数据库：
>   Add-Migration InitialCreate
>   Update-Database

> 11. EnsureCreated 不创建迁移历史记录表，因此不能与迁移一起使用。 它专门用于在频繁删除并重新创建 DB 的情况下进行测试或快速制作原型。

